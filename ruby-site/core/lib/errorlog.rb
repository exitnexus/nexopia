def overload_exception()
	Exception.class_eval {
		# log_level indicates what level the error should be logged at.
		# must be either :error or :critical.
		def log_level()
			return :error;
		end

		# warn_level indicates what level a throw of this error should log at,
		# regardless of whether or not it was caught. Must be :warning, :info, or
		# :debug. Nil will prevent it from logging at all.
		def warn_level()
			return nil;
		end

		# facility is the logging facility that the error will go to.
		def facility()
			return :general;
		end

		alias real_initialize initialize;
		def initialize(*args)
			real_initialize(*args);
			$log.error(self, caller, true);
		end
	}
end

# All exception classes generated by site-specific code should derive from this
# one.
class SiteError < StandardError
	# SiteErrors are, by default, logged at :debug level even if not caught.
	def warn_level()
		return nil;
	end
end

# This class manages logging error/warning/whatever information to a system log.
# Log levels are:
#  - :critical (highest)
#  - :error
#  - :warning
#  - :info
#  - :debug (lowest)
class ErrorLog
	LogLevels = {
		:debug => 0,
		:info => 1,
		:warning => 2,
		:error => 3,
		:critical => 4
	};

	attr_reader :stderr_pid;

	# Describes a log entry ass passed to the log_* functions.
	LogBufferItem = Struct.new('LogBufferItem', :time, :realstr, :level, :facility);

	# pass the target(s) the errorlog should be output to to new(). Defaults
	# to :stderr. Valid values are currently:
	#  :stderr - to stderr
	#  :page - to the currently running page, directly mingled with the output
	#  :syslog - to the syslog daemon on the local machine.
	#  :logfile - to a logfile called logs/site/#{facility}
	#  :logfile_#{something} - to a logfile called logs/site/#{something}
	#  :request_buffer - to a request buffer (see PageRequest#log) called #{facility}
	#  :request_buffer_#{something} - to a request buffer (see PageRequest#log) called #{something}
	def initialize(default_minlevel = :warning, facilities = {:general => [:stderr], :sql => [:sql_logfile, :request_buffer]})
		@colorize_log_output = $config.colorize_log_output
		begin
			require 'text/highlight'
		rescue LoadError
			@colorize_log_output = false
		end

		@facilities = facilities;
		@targets = nil; # to overload targets for a period.
		@facility = :general;
		@default_minlevel = default_minlevel
		@highlighter = @colorize_log_output && Text::ANSIHighlighter.new

		@debugstderr = nil;
		@realstderr = STDERR;
		@realstdout = STDOUT.dup();

		@stderr_pid = nil;

		overload_exception();
	end

	# replace stderr with something we can read from. Do it on the actual
	# file descriptor.
	def redirect_stderr()
		if (@debugstderr.nil?)
			@realstderr = STDERR.dup();

			origpid = Process.pid;

			stderr_read, stderr_write = IO.pipe();
			@stderr_pid = fork {
				$0 = "nexopia-logger for #{origpid}";
				stderr_read.each_line {|line|
					level = if (line.include? 'warning:')
						:warning
					else
						:error
					end
					info(line, level);
				}
				exit(0);
			}

			IO.for_fd(2, 'w').reopen(stderr_write);

			@debugstderr = stderr_write;
			$stderr = STDERR;
		end
	end

	def reassert_stderr()
		# this branch reasserts our stderr from within a cgi handler.
		if (@debugstderr)
			STDERR.reopen(@debugstderr);
			$stderr = STDERR;
		end
	end

	# Logs the information from an actual exception thrown. $! is error, $@ is
	# backtrace. is_warning is either true or false, indicating use warn_level or
	# log_level respectively.
	def error(error, backtrace, is_warning = false)

		# This should really do more work to make the output cleaner, but this'll
		# work for now.

		out = "#{error}\n";
		backtrace.each { |line|
			out += "#{line}\n";
			if (is_warning) # only log the last stack of a warning.
				break;
			end
		}

		info("#{out}", is_warning ? error.warn_level : error.log_level, error.facility);
	end

	# Logs a string at the specified level to the configured targets.
	def info(string, level = :info, facility = @facility)
		minlevel = log_minlevel_for(facility)
		if (level && LogLevels[level] >= LogLevels[minlevel])
			# Get the targets for the given facility, and fall back to :general
			# if it's not found.
			targets = @targets || @facilities.fetch(facility) { @targets || @facilities[:general]; };

			targets.each {|target|
				send("log_#{target}", string, level, facility);
			}
		end
	end

	def timestr()
		Time.now.strftime("%b %d %Y, %H:%M:%S");
	end

	def detailed_string(facility, level, string, time = nil)
		if (time)
			"#{time}.#{Process.pid}.#{facility}.#{level}:#{string}"
		else
			"#{Process.pid}.#{facility}.#{level}:#{string}"
		end
	end

	# Logs an object's var_get() to the configured targets
	def object(object, level = :info, facility = @facility)
		info(object.var_get(), level, facility);
	end

	# Passes the string directly to stderr.
	def log_stderr(realstr, level, facility)
		if (@colorize_log_output)
			realstr = colorize(level, realstr)
			level = colorize(level, level)
			facility = colorize(facility, facility)
			time = colorize(:time, timestr)
			@realstderr.puts(detailed_string(facility, level, realstr, time));
		else
			@realstderr.puts(detailed_string(facility, level, realstr, timestr));
		end
	end

	def colorize(symbol, string)
		return "#{@highlighter.foreground($config.colors(symbol))}#{string}#{@highlighter.reset}"
	end
	# Passes the *real* string directly to stdout. Mostly for the dispatch-test
	# script.
	def log_direct(realstr, level, facility)
		if (@realstdout.respond_to?(:raw_puts))
			@realstdout.raw_puts(realstr);
		else
			@realstdout.puts(realstr);
		end
	end

	# Logs to a page being displayed if there is one, otherwise fails.
	def log_page(realstr, level, facility)
		# replaced by pagehandler once it's loaded
	end

	# Passes the string to syslog at a level mapped to syslog loglevels.
	def log_syslog(realstr, level, facility)
		require "syslog";
		syslog_level = case level
			when :debug then Syslog::LOG_DEBUG;
			when :info then Syslog::LOG_INFO;
			when :warning then Syslog::LOG_WARNING;
			when :error then Syslog::LOG_ERR;
			when :critical then Syslog::LOG_CRIT;
		end

		@syslog = @syslog || Syslog.open($0, 0, Syslog::LOG_LOCAL1)
		@syslog.log(syslog_level, "%s", detailed_string(facility, level, realstr));
	end

	# Writes to an error log file in the site_base_dir directory.
	def logfile(filename, realstr, level, facility)
		File.open("#{$config.site_base_dir}/logs/site/#{filename}.log", "a") {|logfile|
			logfile.puts(detailed_string(facility, level, realstr, timestr));
		}
	end

	# Writes to an internal buffer that can be retrieved via the pagerequest
	def request_buffer(buffername, realstr, level, facility)
		# Replaced on load of pagerequest.rb
	end

	# forwards to logfile with the filename the same as facility.
	def log_logfile(realstr, level, facility)
		logfile(facility, realstr, level, facility);
	end

	# forwards to a request buffer with the buffername the same as the facility
	def log_request_buffer(realstr, level, facility)
		request_buffer(facility, realstr, level, facility);
	end

	# Handles forwarding unkown logfile_* targets to the logfile function.
	def method_missing(name, *args)
		if (matches = /^log_(logfile|request_buffer)_(.*)$/.match(name.to_s))
			send(matches[1].to_sym, matches[2].to_sym, *args);
		else
			super(name, *args);
		end
	end

	# Pass a set of targets to forcefully log to them for the duration of the block
	# passed in. Ie.
	# $log.log_to(:logfile) { $log.info("hello"); }
	def to(*targets)
		@targets = targets;
		begin
			yield
		ensure
			@targets = nil;
		end
	end

	# Pass a facility to use as the default log facility for the block passed in
	def facility(facility)
		facility, @facility = @facility, facility; # swap the given facility and the default
		begin
			yield
		ensure
			facility, @facility = @facility, facility; # swap back.
		end
	end
	
	# get the log level for a particular facility
	def log_minlevel_for(facility)
		@log_minlevel_lower_override ||= {}
		@log_minlevel_raise_override ||= {}
		default_level = if ($site)
			$site.config.log_minlevel_for(facility)
		else
			@default_minlevel
		end
		lower_override_level = @log_minlevel_lower_override[facility]
		raise_override_level = @log_minlevel_raise_override[facility]
		
		level = if (lower_override_level && LogLevels[lower_override_level] < LogLevels[default_level])
			lower_override_level
		else
			default_level
		end

		level = if (raise_override_level && LogLevels[raise_override_level] > LogLevels[level])
			raise_override_level
		else
			level
		end
	
	end
	
	# set the log minlevel for the facilit(ies|y) given to minlevel, unless they're
	# already lower than that (ie. set_log_minlevel_for(:admin, :info) when :admin is
	# set to :debug will leave it at :debug)
	def log_minlevel_lower(facilities, minlevel)
		facilities = [*facilities]
		tmp = {}
		begin
			facilities.each {|facility|
				tmp[facility] = @log_minlevel_lower_override[facility]
				@log_minlevel_lower_override[facility] = minlevel
			}
			yield
		ensure
			facilities.each {|facility|
				@log_minlevel_lower_override[facility] = tmp[facility]
			}
		end
	end

	# set the log minlevel for the facilit(ies|y) given to minlevel, unless they're
	# already higher than that (ie. set_log_minlevel_for(:admin, :info) when :admin is
	# set to :critical will leave it at :critical)
	def log_minlevel_raise(facilities, minlevel)
		facilities = [*facilities]
		tmp = {}
		begin
			facilities.each {|facility|
				tmp[facility] = @log_minlevel_raise_override[facility]
				@log_minlevel_raise_override[facility] = minlevel
			}
			yield
		ensure
			facilities.each {|facility|
				@log_minlevel_raise_override[facility] = tmp[facility]
			}
		end
	end

end
