require 'stringio'

def overload_exception()
	Exception.class_eval {
		# log_level indicates what level the error should be logged at.
		# must be either :error or :critical.
		def log_level()
			return :error;
		end

		# warn_level indicates what level a throw of this error should log at,
		# regardless of whether or not it was caught. Must be :warning, :info, or
		# :debug. Nil will prevent it from logging at all.
		def warn_level()
			return nil;
		end

		# facility is the logging facility that the error will go to.
		def facility()
			return :general;
		end

		alias real_initialize initialize;
		def initialize(*args)
			real_initialize(*args);
			$log.error(self, caller, true);
		end
	}
end

# All exception classes generated by site-specific code should derive from this
# one.
class SiteError < StandardError
	# SiteErrors are, by default, logged at :debug level even if not caught.
	def warn_level()
		return nil;
	end
end

# This class manages logging error/warning/whatever information to a system log.
# Log levels are:
#  - :critical (highest)
#  - :error
#  - :warning
#  - :info
#  - :debug (lowest)
class ErrorLog
	LogLevels = {
		:spam     => 0,
		:debug    => 1,
		:info     => 2,
		:warning  => 3,
		:error    => 4,
		:critical => 5
	};

	attr_reader :stderr_pid;

	# Describes a log entry ass passed to the log_* functions.
	LogBufferItem = Struct.new('LogBufferItem', :time, :realstr, :level, :facility);

	# pass the target(s) the errorlog should be output to to new(). Defaults
	# to :stderr. Valid values are currently:
	#  :stderr - to stderr
	#  :page - to the currently running page, directly mingled with the output
	#  :syslog - to the syslog daemon on the local machine.
	#  :logfile - to a logfile called logs/site/#{facility}
	#  :logfile_#{something} - to a logfile called logs/site/#{something}
	#  :request_buffer - to a request buffer (see PageRequest#log) called #{facility}
	#  :request_buffer_#{something} - to a request buffer (see PageRequest#log) called #{something}
	def initialize(default_minlevel = :warning, facilities = {:general => [:stderr], :sql => [:sql_logfile, :request_buffer]})
		@colorize_log_output = $config.colorize_log_output
		begin
			require 'text/highlight'
		rescue LoadError
			@colorize_log_output = false
		end

		begin
			require 'syslog'
		rescue LoadError
		end

		@facilities = facilities;
		@targets = []; # to overload targets for a period.
		@facility = :general;
		@default_minlevel = default_minlevel
		@highlighter = @colorize_log_output && Text::ANSIHighlighter.new

		@debugstderr = nil;
		@realstderr = STDERR;
		@realstdout = STDOUT.dup();

		@stderr_pid = nil;

		overload_exception();
	end

	# replace stderr with something we can read from. Do it on the actual
	# file descriptor.
	def redirect_stderr()
		if (@debugstderr.nil?)
			@realstderr = STDERR.dup();

			origpid = Process.pid;

			stderr_read, stderr_write = IO.pipe();
			@stderr_pid = fork {
				$0 = "nexopia-logger for #{origpid}";

			#Keep the logger process around for an extra 0.1s after a SIGTERM. This is because any
			#errors in the parents will kill the logger, but still try to output stuff, which fails.
			#This way the extra output actually gets logged.
				trap("SIGTERM"){
					Thread.new {
						sleep(0.1);
						exit(0);
					}
				}

				stderr_read.each_line {|line|
					level = if (line.include? 'warning:')
						:warning
					else
						:error
					end
					info(line, level);
				}
				exit(0);
			}

			IO.for_fd(2, 'w').reopen(stderr_write);

			@debugstderr = stderr_write;
			$stderr = STDERR;
		end
	end


	# Set up logging for any special cases that we want to track.
	def setup_special_logging
		# Redefine this deprecated method to properly log through our logging mechanism (so
		# that a developer will see it even when in single thread view) and also log a 
		# stacktrace so that we can see where it's coming from. Return object_id, which should
		# be equivalent.
		Object.send :define_method, :id, lambda {
			# For known issue logging
			$log.info "KNOWN ISSUE NEX-900: Accessing deprecated Object method on class: #{self.class}", :warning
			# Ruby's original warning message
			$log.info "Object#id will be deprecated; use Object#object_id", :warning
			$log.object caller, :warning
			return object_id
		}
	end


	def reassert_stderr()
		# this branch reasserts our stderr from within a cgi handler.
		if (@debugstderr)
			STDERR.reopen(@debugstderr);
			$stderr = STDERR;
		end
	end

	# Logs the information from an actual exception thrown. $! is error, $@ is
	# backtrace. is_warning is either true or false, indicating use warn_level or
	# log_level respectively.
	def error(error = $!, backtrace = $@, is_warning = false)

		# This should really do more work to make the output cleaner, but this'll
		# work for now.
		out = StringIO.new()
		
		if (error.respond_to?(:page_request))
			out << ":#{error.page_request.area}#{error.page_request.uri}"
			if (!error.page_request.session.user.anonymous?)
				out << " suser=#{error.page_request.session.user.username},suid=#{error.page_request.session.user.userid}"
			end
			if (error.page_request.user)
				out << " puser=#{error.page_request.user.username},puid=#{error.page_request.user.userid}"
			end
			out << ": "
		end
		out.puts(error)
		backtrace.each { |line|
			out.puts(line)
			if (is_warning) # only log the last stack of a warning.
				break;
			end
		}

		info(out.string, is_warning ? error.warn_level : error.log_level, error.facility);
	end

	# Logs a string at the specified level to the configured targets.
	def info(string, level = :info, facility = @facility)
		minlevel = log_minlevel_for(facility)
		if (level && LogLevels[level].nil?)
			raise "Invalid log level: #{level} provided."
		end
		if (level && LogLevels[level] >= LogLevels[minlevel])
			# Get the targets for the given facility, and fall back to :general
			# if it's not found.
			targets = @targets + @facilities.fetch(facility) { @targets.empty? ? @facilities[:general] : @targets };

			targets.uniq.each {|target|
				send("log_#{target}", string, level, facility);
			}
		end
	end

	def userstr
		return nil unless(defined? PageRequest) #needed since PageRequest is defined after errorlog is loaded
		req = PageRequest.current
		return nil unless req

		if(evaluated?(req.session))
			return "#{req.session.userid}/#{req.get_ip}"
		else
			return req.get_ip
		end
	end

	#put in constants so they don't get created each time.
	LOG_TIME_FORMAT = "%b %d %y, %H:%M:%S."
	LOG_TIME_FORMAT_MS = "%04i"

	def timestr()
		time = Time.now
		return time.strftime(LOG_TIME_FORMAT) + format(LOG_TIME_FORMAT_MS, ((time.to_f - time.to_i) * 10000))
	end

	def detailed_string(facility, level, string, time = nil, user = nil, pid = Process.pid)
		str = ""
		str << "#{time} "  if time
		str << "[#{user}] " if user
		str << "#{$site.config_name}." if $site && $site.config_name
		str << "#{pid}.#{facility}.#{level}"
		str << " (#{PageRequest.top.token})" if Object.const_defined?(:PageRequest) && PageRequest.top
		str << ": #{string}"
		return str
	end

	# Logs an object's var_get() to the configured targets
	def object(object, level = :info, facility = @facility)
		info(object.var_get(), level, facility);
	end

	# Passes the string directly to stderr.
	def log_stderr(realstr, level, facility)
		realstr = realstr.to_s.strip
		if (@colorize_log_output)
			realstr = colorize(level, realstr)
			level = colorize(level, level)
			facility = colorize(facility, facility)
			time = colorize(:time, timestr)
			user = colorize(:user, userstr)
			pid = colorize(:pid, Process.pid)
			@realstderr.puts(detailed_string(facility, level, realstr, time, user, pid));
		else
			@realstderr.puts(detailed_string(facility, level, realstr, timestr, userstr));
		end
		begin
			@realstderr.fsync
		rescue
			@realstderr.flush
		end
	end

	def colorize(symbol, string)
		return nil unless string
		return "#{@highlighter.foreground($config.colors(symbol))}#{string}#{@highlighter.reset}"
	end
	# Passes the *real* string directly to stdout. Mostly for the dispatch-test
	# script.
	def log_direct(realstr, level, facility)
		if (@realstdout.respond_to?(:raw_puts))
			@realstdout.raw_puts(realstr);
		else
			@realstdout.puts(realstr);
		end
	end

	# Logs to a page being displayed if there is one, otherwise fails.
	def log_page(realstr, level, facility)
		# replaced by pagehandler once it's loaded
	end

	# Passes the string to syslog at a level mapped to syslog loglevels.
	def log_syslog(realstr, level, facility)
		syslog_level = case level
			when :spam then Syslog::LOG_INFO;
			when :debug then Syslog::LOG_INFO;
			when :info then Syslog::LOG_INFO;
			when :warning then Syslog::LOG_WARNING;
			when :error then Syslog::LOG_ERR;
			when :critical then Syslog::LOG_CRIT;
		end

		@syslog = @syslog || Syslog.open($0, 0, Syslog::LOG_LOCAL1)
		
		@syslog.log(syslog_level | Syslog::LOG_LOCAL1, "%s", detailed_string(facility, level, realstr, nil, userstr));
	end

	# Writes to an error log file in the site_base_dir directory.
	def logfile(filename, realstr, level, facility)
		File.open("#{$config.site_base_dir}/logs/site/#{filename}.log", "a") {|logfile|
			logfile.puts(detailed_string(facility, level, realstr, timestr, userstr));
		}
	end

	# Writes to an internal buffer that can be retrieved via the pagerequest
	def request_buffer(buffername, realstr, level, facility)
		# Replaced on load of pagerequest.rb
	end

	# forwards to logfile with the filename the same as facility.
	def log_logfile(realstr, level, facility)
		logfile(facility, realstr, level, facility);
	end

	# forwards to a request buffer with the buffername the same as the facility
	def log_request_buffer(realstr, level, facility)
		request_buffer(facility, realstr, level, facility);
	end

	# Handles forwarding unkown logfile_* targets to the logfile function.
	def method_missing(name, *args)
		if (matches = /^log_(logfile|request_buffer)_(.*)$/.match(name.to_s))
			send(matches[1].to_sym, matches[2].to_sym, *args);
		else
			super(name, *args);
		end
	end

	# Pass a set of targets to forcefully log to them for the duration of the block
	# passed in. Ie.
	# $log.log_to(:logfile) { $log.info("hello"); }
	def to(*targets)
		targets, @targets = @targets, targets;
		begin
			yield
		ensure
			targets, @targets = @targets, targets;
		end
	end

	# Pass a facility to use as the default log facility for the block passed in
	def facility(facility)
		facility, @facility = @facility, facility; # swap the given facility and the default
		begin
			yield
		ensure
			facility, @facility = @facility, facility; # swap back.
		end
	end
	
	# get the log level for a particular facility
	def log_minlevel_for(facility)
		@log_minlevel_lower_override ||= {}
		@log_minlevel_raise_override ||= {}
		default_level = if ($site)
			$site.config.log_minlevel_for(facility)
		else
			@default_minlevel
		end
		lower_override_level = @log_minlevel_lower_override[facility]
		raise_override_level = @log_minlevel_raise_override[facility]
		
		level = if (lower_override_level && LogLevels[lower_override_level] < LogLevels[default_level])
			lower_override_level
		else
			default_level
		end

		level = if (raise_override_level && LogLevels[raise_override_level] > LogLevels[level])
			raise_override_level
		else
			level
		end
	
	end
	
	# set the log minlevel for the facilit(ies|y) given to minlevel, unless they're
	# already lower than that (ie. set_log_minlevel_for(:admin, :info) when :admin is
	# set to :debug will leave it at :debug)
	def log_minlevel_lower(facilities, minlevel)
		facilities = [*facilities]
		tmp = {}
		begin
			facilities.each {|facility|
				tmp[facility] = @log_minlevel_lower_override[facility]
				@log_minlevel_lower_override[facility] = minlevel
			}
			yield
		ensure
			facilities.each {|facility|
				@log_minlevel_lower_override[facility] = tmp[facility]
			}
		end
	end

	# set the log minlevel for the facilit(ies|y) given to minlevel, unless they're
	# already higher than that (ie. set_log_minlevel_for(:admin, :info) when :admin is
	# set to :critical will leave it at :critical)
	def log_minlevel_raise(facilities, minlevel)
		facilities = [*facilities]
		tmp = {}
		begin
			facilities.each {|facility|
				tmp[facility] = @log_minlevel_raise_override[facility]
				@log_minlevel_raise_override[facility] = minlevel
			}
			yield
		ensure
			facilities.each {|facility|
				@log_minlevel_raise_override[facility] = tmp[facility]
			}
		end
	end

end
