<?
/* MODULE: userSearch.php */

/* MODULE REVISION
 * $URL$
 * $Revision$
 * $Date$
 * $Author$
 * END MODULE REVISION */

/* OVERVIEW
 * This module provides a unified interface to all functions relating to finding users in the system
 * it contains the userSearch class, along with the userSearchResults, and userSearchResultList classes
 * which act as containers for results returned by userSearch
 * END OVERVIEW */

/* HISTORY
 * Created Jun 16, 2006  by pdrapeau
 * END HISTORY */


/* CLASS: userSearch */

/* SYNOPSIS
 * This class is a container for all user search functions within the system
 * it deals with queries against the stats tables, index tables, and search tables
 * in reguards to user seaches
 *
 * END SYNOPSIS */

/* HISTORY
 * Created May 29, 2006 by pdrapeau
 * END HISTORY */
class userSearch {

	/* BEGIN DEFINE PROPERTIES */
	private $masterdb;			// reference to master database object (PTR)
	private $usersdb;			// reference to users database object (PTR)
	private $configdb;			// reference to the config database object (PTR)
	private $generaldb;			// reference to the general database object (PTR)
	private $cache;				// reference to cache object (PTR)
	private $locationsObj;		// locations from config DB (OBJ)
	private $interestsObj;		// interests from config DB (OBJ)

	private $searchTypes;		// avaliable types of searches (ARRAY)
	private $resultTypes;		// avaliable types of search results (ARRAY)
	private $validResultTypes;	// defination of what result types are valid with each search type (ARRAY)

	private $prequeryMethods;	// methods called before executing actual search queries (ARRAY)
	private $queryMethods;		// query methods to get user results back from database (ARRAY)
	private $resultTypeObjects;	// result type objects matching up with result types (ARRAY)
	private $resultObjectProp;	// properties in this object that need to be passed to the result object (ARRAY)
	private $requiredPropSearch;// required properties that must be set to perform a speific type of search (ARRAY)
	private $requiredPropResult;// required properties that must be set for a specific result set type (ARRAY)

	private $searchType;		// type of search to perform (as defined in constructor)
	private $searchParams;		// search parameter list paired with properties to set from parameters (ARRAY)

	private $uname;				// user name to search by (STRING) or false to exclude
	private $unameType;			// type of username search to perform (STRING: starts/includes/ends) or false to exclude

	private $startAge;			// start of the age range to search by (INT) or false to exclude
	private $endAge;			// end of the age range to search by (INT) or false to exclude
	private $ageRange;			// age range to use in searches (ARRAY)
	private $sex;				// sex to search by (STRING: Male/Female) or false to exclude

	private $location;			// location to search in (INT) or false to exclude
	private $interest;			// interest to query by (INT) or false to exclude
	private $activity;			// activity level to seach by (INT) false = exclude, 1 = Active Recently, 2 = Online
	private $pictures;			// user has pictures (INT) false = exclude, 1 = With Pictures, 2 = Veified Pictures
	private $sexuality;			// sexuality of user (INT) false = exclude, 1 = Hetrosexual, 2 = Homosexual, 3 = Bisexual
	private $singleUsersOnly;	// single users only (BOOL) T = single users, F = exclude

	private $resultType;		// type of results to return (STRING RAND/LIST)
	private $numRandReturned;	// number of random users returned in result set (INT)
	private $randPageSize;		// size of result pages to get for random result sets (INT)
	private $maxRandAttempt;	// maximum number of attempts to get requested number of random results (INT)

	private $pageNumber;		// requested page number of results to get or false to set a random page number (INT)
	private $resultsPerPage;	// requested number of results to get per page (INT)

	private $totalResults;		// total count of results in the database (INT)
	private $resultsInRetSet;	// actual number of results in the returned in a full result set (INT)
	private $pageStartIdx;		// start array IDX for requested page of results in a full result set (used with $resultsInRetSet) (INT)
	private $pageEndIdx;		// end array IDX for requested page of results in a full result set (used with $resultsInRetSet) (INT)
	private $numberOfPages;		// number of pages in result set (INT)
	private $resultsOnPage;		// actual number of results on the requested (current) page of the result set (INT)

	private $queryParts;		// parts of the SQL query as generated by preQuery methods (ARRAY)
	private $uidSearchRange;	// UID search ranges used in the database (ARRAY)

	private $ageMin;			// minimum search age (INT)
	private $ageMax;			// maximum search age (INT)

	private $agesexGroupCols;	// columns that are avaliable in the agesexgroupstable (ARRAY)

	private $siteStats;			// site stats (ARRAY)
	private $factors;			// factors used to calculate matching users (ARRAY)
	private $locs;				// array of locs that are contained in the specified loc
	private $prequeryRan;		// prequery has been ran for search params (BOOL)

	private $debug;				// true/false enable debug and performance stats (BOOL)
	private $debugFlags;		// debug flags -- which levels of debug messages to display (ARRAY)
	private $writeDebug;		// write debug to log file output (BOOL)
	private $debugOutput;		// all lines of debug output for an individual query (ARRAY)
	private $timers;			// array of timers used for profiling functions etc
	private $dbHitTime;			// amount of time taken hitting the database (total) for an entire query
	private $cacheHitTime;		// amount of time taken hitting the cache (total) for an entire query
	/* END DEFINE PROPERTIES */


	/* BEGIN CONSTRUCTOR */
	function __construct (
		$searchType,			// I: type of search to perform
		$resultType,			// I: type of result set to give back
		$debug	= false			// I: true/false enable/disable debug
	) {
		// pull in references to database and cache objects from the global scope
		global $masterdb, $usersdb, $configdb, $db, $cache;
		$this->masterdb = &$masterdb;
		$this->usersdb = &$usersdb;
		$this->generaldb = &$db;
		$this->configdb = &$configdb;
		$this->cache = &$cache;

		// enable debugging (TRUE/FALSE)
		$this->debug = $debug;

		// write debug log to error_log
		$this->writeDebug = false;

		// set which levels of debug messages will be displayed
		$this->debugFlags = array (	'SQL'			=> true,
									'STATS' 		=> true,
									'EXECPROFILE' 	=> true,
									'INFO' 			=> true);

		// get the minimum and maximum ages from the global scope, and set within object
		global $systemAgeMin, $systemAgeMax;
		$this->ageMin = $systemAgeMin;
		$this->ageMax = $systemAgeMax;

		// define the types of searches that are avaliable
		$this->searchTypes = array(	0 	=> 'NEWUSERS',
									1	=> 'NEWPROFILE',
 									2 	=> 'BDAY',
 									3 	=> 'USERSEARCH',
 									4	=> 'SPOTLIGHT',
 									5	=> 'ALLUSERS' );

 		// define what types of search results are avaliable
 		$this->resultTypes = array ( 0	=> 'LIST',
 									 1	=> 'RAND', );

 		// define which result types are valid with each of the search types
 		$this->validResultTypes = array (	'NEWUSERS'		=> array('LIST'),
 											'NEWPROFILE'	=> array('LIST'),
 											'BDAY'			=> array('LIST'),
 											'USERSEARCH' 	=> array('LIST', 'RAND'),
 											'SPOTLIGHT' 	=> array('LIST'),
 											'ALLUSERS' 		=> array('RAND'));

		// these are methods which are called prior to the queryMethod, they may be used to
		// form parts of the query, or to set stats based on the parameters set, for each search type the
		// first param is the method called, with the reamining indexes in the array being parameters
		// which are passed into the called method. These methods must return true on there being results
		// (thus the query method is than executed) or false on no results (thus the query method is not executed)
 		$this->prequeryMethods = array( 'NEWUSERS'		=> false,
 										'NEWPROFILE'	=> false,
 									 	'BDAY'			=> false,
 									 	'USERSEARCH'	=> array('prequeryUserSearch', true),
 									 	'SPOTLIGHT'		=> false,
 										'ALLUSERS'		=> false );

 		// define methods for getting result sets for each search, and function exactly the same as the prequery
 		// methods, except that these methods return a result set, or false if there are no results
 		$this->queryMethods = array( 'NEWUSERS'		=> array('queryNewUsers'),
 									 'NEWPROFILE'	=> array('queryNewProfile'),
 									 'BDAY'			=> array('queryBdayUsers'),
 									 'USERSEARCH'	=> array('queryUserSearch'),
 									 'SPOTLIGHT'	=> array('querySpotLight'),
 									 'ALLUSERS'		=> array('queryAllUsers'));

 		// define objects used to contain search results
 		$this->resultTypeObjects = array(	'LIST'	=> "userSearchResultsList",
 											'RAND'	=> "userSearchResults");

 		// define object properties that need to be passed into construct on result objects	after result set
 		$this->resultObjectProp = array(	'LIST'	=> array('totalResults','numberOfPages','resultsOnPage','pageNumber','resultsInRetSet','pageStartIdx','pageEndIdx'),
 											'RAND'	=> array('totalResults'));

 		// if debug is enabled, add debug output to last param of result object
 		if ($this->debug === true)
 			foreach ($this->resultObjectProp as $resultParamKey => $resultParamValues)
 				$this->resultObjectProp[$resultParamKey][] = 'debugOutput';

 		// define what properties must be set for each search type before calling search()
 		$this->requiredPropSearch = array (	);

 		// define what properties must be set for each result type
 		$this->requiredPropResult = array (	'LIST'	=> array('pageNumber', 'resultsPerPage'),
 											'RAND'	=> array('numRandReturned'));

 		// set what parameters may be set upon calling the search() method (parameters will be taken in the same
 		// order as they are defined) this is based on the resultType that is set, as parameters going into
 		// a search are set before executing the search function, and also is used to set the required param number
 		$this->searchParams = array (	'LIST'	=> array('pageNumber', 'resultsPerPage'),
 										'RAND'	=> array('numRandReturned'));


 		// set size of pages grabbed for random result sets, and max number of page fetches allowed
 		$this->randPageSize = "25";
 		$this->maxRandAttempt = "5";

 		// set what columns are avaliable in the agesexgroups table in the database
 		$this->agesexGroupCols = array ( 	'total' => true,
 											'active' => true,
 											'pics'	=> true,
 											'signpics' => true,
 											'activepics' => true,
 											'activesignpics' => true,
 											'single' => true,
 											'sexuality1' => true,
 											'sexuality2' => true,
 											'sexuality3' => true);


 		// sanity checks on construct parameters
 		if (!in_array($searchType, $this->searchTypes))
 			trigger_error("userSearch->construct: invalid search type ($searchType) on construct", E_USER_ERROR);
 		if (!in_array($resultType, $this->resultTypes))
			trigger_error("userSearch->construct: invalid result type ($resultType) on construct", E_USER_ERROR);
		if (!in_array($resultType, $this->validResultTypes[$searchType]))
			trigger_error("userSearch->construct: invalid result type ($resultType) for search type $searchType", E_USER_ERROR);

		// insure correct database objects have been passed in
 		if (!isset($masterdb) || get_class($masterdb) != "multiple_sql_db")
 			trigger_error("userSearch->construct: masterdb not provided or incorrect type", E_USER_ERROR);

 		if (!isset($usersdb) || get_class($usersdb) != "multiple_sql_db_split")
 			trigger_error("userSearch->construct: usersdb not provided or incorrect type", E_USER_ERROR);

 		// search and result types
 		$this->searchType = $searchType;
 		$this->resultType = $resultType;

 		// search parameters
 		$this->uname = false;
 		$this->unameType = false;
 		$this->startAge = false;
 		$this->endAge = false;
 		$this->ageRange = false;
 		$this->sex = false;
 		$this->location = false;
 		$this->interest = false;
 		$this->activity = false;
 		$this->pictures = false;
 		$this->sexuality = false;
 		$this->singleUsersOnly = false;

 		// db related values
 		$this->uidSearchRange = false;

 		// set properties that get set upon each search
 		$this->resetProperties();
 	}
	/* END CONSTRUCTOR */


	/* METHOD: debug */

	/* SYNOPSIS
	 * This method receives any debug messages that may be generated by the search script
	 * and than processes them accordingly (presently using the error_log function)
	 * END SYNOPSIS */

	/* HISTORY
	 * Created May 30, 2006 by pdrapeau
	 * END HISTORY */
	private function debug (
		$level,					// I: level of message (or array of two elements to specifiy sublevel tags)
		$message,				// I: message or message and sublevel pair
		$timerParams = false	// I: param list for timer, or false (this will replace the contents of $message
	) {
 		if ($this->debug === false)
 			return true;

 		if (isset($this->debugFlags[$level]) === false || $this->debugFlags[$level] === false)
 			return false;

		if (is_array($message)) {
			$subLevel = $message[0];
			$message = $message[1];
		} else {
			$subLevel = "";
		}

 		// this is just to simply call the timer method as part of the debug output as opposed to the messy eval code
 		// which was being used before
 		if ($timerParams !== false) {
 			$message = call_user_func_array(array(&$this, 'timer'), $timerParams);
 			$message = trim($message);
 			if ($message == "")
 				return true;
 		}

 		// okay next deal with messages that are multiple lines
 		$messages = split("\n", $message);

 		// come up with leading tag
 		$leadingTag = '[userSearch:'.$level.']';

 		// define the length where single line messages get split into multi-line messages
 		$splitLen = 100;

 		// init date tag
 		$dateTag = gmdate("[d-M-Y H:i:s]");

 		// output the message to the error log and return if theres a single message below a certian length
 		if (count($messages) == 1) {
 			$output = array_shift($messages);
 			if ((strlen($output)+strlen($leadingTag)) > $splitLen) {
 				$messages = str_split($output, ($splitLen-strlen($subLevel)));
 			} else {
 				$output = $leadingTag.' '.$output;
 				if ($this->writeDebug === true)
   				error_log($output);
 				$this->debugOutput[] = $dateTag.' '.$output;
 				return true;
 			}
 		}

 		// init vars for multi-line messages
		$indent = "\t";
 		$longestLen = 0;
 		$output = "";

 		// format each line of output, storing into one string
 		foreach ($messages as $line) {
 			if ($line == "")
 				continue;

 			if ($subLevel != "")
	 			$line = $dateTag.' '.$indent.'  '.$subLevel.' ==> '.$line;
 			else
 				$line = $dateTag.' '.$indent.'  ==> '.$line;
	 		$length = strlen($line);
	 		if ($length > $longestLen)
	 			$longestLen = $length;
 			$output .= "\n".$line;
 		}

 		// splice the strings together for output as one error_log item (thus insuring that portions of multi-line
 		// log messages don't get intermixed with other log messages)
 		$separatorLen = $longestLen - (strlen($dateTag)+strlen($leadingTag));
 		$separator = str_repeat("=", $separatorLen);
 		$startTag = "$leadingTag ".$separator.">";
 		$endTag = "\n".$dateTag.' '.$leadingTag." ".$separator.">";
 		$output = $startTag.$output.$endTag;

 		$this->debugOutput[] = $dateTag.' '.$output;

 		if ($this->writeDebug === true)
   			error_log($output);

 		return true;
	}
	/* END METHOD debug */


	/* METHOD: timer */

	/* SYNOPSIS
	 * This method is used for timing events that happen in the script (for profiling information)
	 * END SYNOPSIS */

	/* HISTORY
	 * Created May 30, 2006 by pdrapeau
	 * END HISTORY */
	private function timer (
		$timerName,			// I: name of the timer that the command is being passed to
		$command,			// I: command to pass to timer
		$param	= false		// I: param to pass to timer
	) {
		switch ($command) {
			case 'start':
				$this->timers[$timerName] = Array(	'lapTimes' => Array(),
												  	'lapStart' => microtime(true));

				return "[TIMER:$timerName] [START] timer has been started";
				break;
			case 'lap':
				$lapTime = microtime(true);
				$diff = $lapTime - $this->timers[$timerName]['lapStart'];
				$formattedDiff = number_format($diff*1000, 2);
				$this->timers[$timerName]['lapTimes'][] = Array('lapDesc' => $param,
																'lapTime' => $lapTime,
																'rawTimeDiff' => $diff,
																'formattedDiff' => $formattedDiff);

				$this->timers[$timerName]['lapStart'] = microtime(true);
				return "";
				break;
			case 'done':
				$lapTime = microtime(true);
				$returnString =  "[TIMER:$timerName] [END] timer has been stopped, summery is as follows...\n";
				$diff = $lapTime - $this->timers[$timerName]['lapStart'];
				$formattedDiff = number_format($diff*1000, 2);
				$this->timers[$timerName]['lapTimes'][] = Array('lapDesc' => $param,
																'lapTime' => $lapTime,
																'rawTimeDiff' => $diff,
																'formattedDiff' => $formattedDiff);
																$lapTimes = $this->timers[$timerName]['lapTimes'];
				$lapTimeSum = 0;
				foreach ($lapTimes as $lap) {
					$returnString .= "[TIMER:$timerName] [LAPTIME] [".str_pad($lap['formattedDiff'], "6", " ",STR_PAD_LEFT)."ms] ".$lap['lapDesc']."\n";
					$lapTimeSum += $lap['rawTimeDiff'];
				}
				$lapTimeSum = number_format($lapTimeSum*1000, 2);
				$returnString .= "[TIMER:$timerName] [TOTAL]   [".str_pad($lapTimeSum, "6", " ",STR_PAD_LEFT)."ms] total execution time is $lapTimeSum"."ms";
				unset($this->timers[$timerName]);
				return $returnString;
				break;
		}
	}
	/* END METHOD timer */


	/* METHOD: resetProperties */

	/* SYNOPSIS
	 * This method resets the properties in the object (to be called on construct and after each search)
	 * END SYNOPSIS */

	/* HISTORY
	 * Created May 30, 2006 by pdrapeau
	 * END HISTORY */
	private function resetProperties () {

		// result set parameters
 		$this->totalResults = false;
		$this->resultsInRetSet = false;
		$this->pageStartIdx = false;
		$this->pageEndIdx = false;
 		$this->pageNumber = false;
 		$this->resultsPerPage = false;
 		$this->numRandReturned = false;
 		$this->resultsOnPage = false;
 		$this->numberOfPages = false;

 		// result sets
 		$this->resultCount = 0;

 		// stats
 		$this->siteStats = false;
 		$this->factors = Array();
 		$this->prequeryRan = false;

 		// SQL query parts
 		$this->queryParts = false;

 		// locs
 		$this->locs = false;


 		// re-set performance stats type stuff
		$this->timers = Array();
		$this->dbHitTime = 0;
		$this->cacheHitTime = 0;


		// clear debug output
		$this->debugOutput = Array();

 		return true;
	}
	/* END METHOD resetProperties */


	/* BEGIN SET METHODS */

	/* SYNOPSIS
	 * These methods set properties within the object, performing sanity checks on the vars passed to them
	 * END SYNOPSIS */

	/* HISTORY
	 * Created May 31, 2006 by pdrapeau
	 * END HISTORY */
	function setAgeRange (
		$startAge,	// I: start of age range to search by
		$endAge		// I: end of age range to search by
	) {
		$startAge = intval($startAge);
		$endAge = intval($endAge);

//		if (empty($startAge) || empty($endAge))
//			trigger_error("userSearch->setAgeRange: startAge and endAge are required and must be integers", E_USER_ERROR);

		if (empty($startAge) || $startAge < $this->ageMin)
			$startAge = $this->ageMin;
		if (empty($endAge) || $endAge > $this->ageMax)
			$endAge = $this->ageMax;

		if($startAge > $endAge){
			$temp = $startAge;
			$startAge = $endAge;
			$endAge = $temp;
		}

		$this->startAge = $startAge;
		$this->endAge = $endAge;
		$this->ageRange = range($startAge, $endAge);
		return true;
	}


	function setSex (
		$sex	// I: sex to search by
	) {
		if (empty($sex))
			trigger_error("userSearch->setSex: sex is a required parameter", E_USER_ERROR);

		if (!is_string($sex))
			trigger_error("userSearch->setSex: sex must be a string", E_USER_ERROR);

		if ($sex != 'Male' && $sex != 'Female')
			trigger_error("userSearch->setSex: sex must be 'Male' or 'Female'", E_USER_ERROR);

		$this->sex = $sex;
		return true;
	}


	function setLocation (
		$location	// I: ID of location to query in (INT)
	) {
		$location = intval($location);

		if (empty($location))
			return true;

		$this->locationsObj = new category( $this->configdb, "locs");
		if (!$this->locationsObj->isValidCat($location))
			trigger_error("userSearch->setLocation: location ID is invalid", E_USER_ERROR);

		$this->location = $location;
		return true;
	}


	function setInterest (
		$interest // I: ID of interest to query by (INT)
	) {
		$interest = intval($interest);

		if (empty($interest))
			trigger_error("userSearch->setInterest: interest is a require parameter and must be an integer", E_USER_ERROR);

		$this->interestsObj = new category( $this->configdb, "interests");
		if (!$this->interestsObj->isValidCat($interest))
			trigger_error("userSearch->setInterest: interest ID is invalid", E_USER_ERROR);

		$this->interest = $interest;
		return true;
	}


	function setActivity (
		$activity 	// I: activity level to query by (INT)
	) {
		$activity = intval($activity);

		if (empty($activity))
			trigger_error("userSearch->setActivity: activity is a require parameter and must be an integer", E_USER_ERROR);

		if ($activity < 1 || $activity > 2)
			trigger_error("userSearch->setActivity: activity must be either 1 (active recently) or 2 (online)", E_USER_ERROR);

		$this->activity = $activity;
		return true;
	}


	function setPictures (
		$pictures	// I: pictures on profile (INT)
	) {
		$pictures = intval($pictures);

		if (empty($pictures))
			trigger_error("userSearch->setPictures: pictures is a required parameter and must be an integer", E_USER_ERROR);

		if ($pictures < 1 || $pictures > 2)
			trigger_error("userSearch->setPictures: pictures must be either 1 (has pictures or 2 (has verified pictures)", E_USER_ERROR);

		$this->pictures = $pictures;
	}


	function setSexuality (
		$sexuality	// I: sexuality to query by (INT)
	) {
		$sexuality = intval($sexuality);

		if (empty($sexuality))
			trigger_error("userSearch->setSexuality: sexuality is a required parameter and must be an integer", E_USER_ERROR);

		if ($sexuality < 1 || $sexuality > 3)
			trigger_error("userSearch->setSexuality: sexuality must be 1 (Hetrosexual) 2 (Homosexual) 3 (Bisexual)", E_USER_ERROR);

		$this->sexuality = $sexuality;
	}


	function setSingle (
		$singleUsers	// I: query for single users only (BOOL)
	) {
		if (!is_bool($singleUsers))
			trigger_error("userSearch->setSingle: single users must be either true or false", E_USER_ERROR);

		$this->singleUsersOnly = $singleUsers;
	}


	function setUname (
		$uname,		// I: username to search by
		$unameType	// I: type of username search to perform
	) {
		if (empty($uname) || empty($unameType))
			trigger_error("userSearch->setUname: uname and unameType are required params", E_USER_ERROR);

		if (!is_string($unameType) || !is_string($uname))
			trigger_error("userSearch->setUname: uname and unameType must be strings", E_USER_ERROR);

		if ($unameType != 'starts' && $unameType != 'includes' && $unameType != 'ends')
			trigger_error("userSearch->setUname: unameType must be one of starts, includes, ends", E_USER_ERROR);


		$uname = $this->usersdb->escape($uname);
		$this->uname = $uname;
		$this->unameType = $unameType;

	}
	/* END SET METHODS */


	/* BEGIN: SET FACTOR/STATS METHODS */

	/* SYNOPSIS
	 * These methods are used internally by the class to get stats counts for users, and to generate factors (
	 * fractions of users) based on those stats
	 * END SYNOPSIS */

	/* HISTORY
	 * Created May 31, 2006 by pdrapeau
	 * END HISTORY */
	private function setSiteStats () {
		if ($this->siteStats === false) {
			$this->siteStats = updateStats();

			if ($this->debug === true) {
				$debugString = "";
				$line = false;
				foreach (array_chunk($this->siteStats, 3, true) as $values) {
					foreach ($values as $name => $value)
						$debugString .= str_pad("$name = $value ", "23", " ");
					$debugString .= "\n";
				}
				$this->debug("STATS", array('[SITESTATS]',$debugString));
			}
		}
		return true;
	}

	private function setAgeSexStats (
		$sex,			// I: sex to set stats for (Male/Female) or false for both
		$ageStart,		// I: age range start to get stats for or false to exclude
		$ageEnd,		// I: age range end to get stats for or false to exclude
		$col = 'total'	// I: table column to use to set stats for defaulting to total
	) {
		// set the site stats if not already set
		$this->setSiteStats();

		if ($this->agesexGroupCols[$col] === false)
			trigger_error("userSearch->setAgeSexStats: $col does not exist in agesexgroups table", E_USER_ERROR);

		// set defaults if parameters are not passed
		if ($sex === false) {
			$sex = Array('Male', 'Female');
			$descSex = "Both";
		} else {
			$descSex = $sex;
		}

		if ($ageStart === false)
			$ageStart = $this->ageMin;

		if ($ageEnd === false)
			$ageEnd = $this->ageMax;


		// figure out if the key for total has been set, if not set it
		if (!isset($this->factors['agesexGrouptotal'])) {
			$numMatchingUsers = getNumUsersInAgeSexCol($sex, $ageStart, $ageEnd, 'total');
			$usersTotal = $this->siteStats['userstotal'];
			$factorValue = Array();
			$factorValue[] = $numMatchingUsers;
			$factorValue[] = ($usersTotal ? (double)$numMatchingUsers/$usersTotal : 0);
			$factorValue['desc'] = "setAgeSexStats ==> sex: $descSex, ageStart: $ageStart, ageEnd: $ageEnd, usersTotal: $usersTotal, col: total";
			$this->debug("STATS", $factorValue['desc']."\n"."matchingUsers: $numMatchingUsers/$factorValue[1]");
			$this->factors['agesexGrouptotal'] = $factorValue;
		}

		// return at this point if the col is total
		if ($col == 'total')
			return true;

		// get the stats based on the parameters in cases where its other than total
		$factorKey = 'agesexGroup'.$col;
		$factorValue = Array();
		$numMatchingUsers = getNumUsersInAgeSexCol($sex, $ageStart, $ageEnd, $col);

		$factorValue[] = $numMatchingUsers;
		$factorValue[] = ($this->factors['agesexGrouptotal'][0] ? (double)$numMatchingUsers/$this->factors['agesexGrouptotal'][0] : 0);
		$factorValue['desc'] = "setAgeSexStats ==> sex: $descSex, ageStart: $ageStart, ageEnd: $ageEnd, agesexGrouptotal: ".$this->factors['agesexGrouptotal'][0].", col: $col";
		$this->debug("STATS", $factorValue['desc']."\n"."matchingUsers: $numMatchingUsers/$factorValue[1]");
		$this->factors[$factorKey] = $factorValue;
		return true;
	}

	private function setLocStats(
		$location		// I: ID of loc to set stats for
	) {
		// set the site stats if not already set
		$this->setSiteStats();

		$locationArr = $this->getSubLocs($location);
		$numUsersLoc = getNumUsersInLocs($locationArr);
		$usersTotal = $this->siteStats['userstotal'];

		$factorValue = Array();
		$factorValue[] = $numUsersLoc;
		$factorValue[] = ($usersTotal ? (double)$numUsersLoc/$usersTotal : 0);
		$desc_line1 = "location: $location (".implode (",", $locationArr).")";
		$desc_line2 = "matchingUsers: $numUsersLoc/$usersTotal = $factorValue[1]";
		$factorValue['desc'] = $desc_line1.' '.$desc_line2;

		$this->debug("STATS", Array('[setLocStats]', $desc_line1."\n".$desc_line2));

		$this->factors['loc'] = $factorValue;
		return true;
	}

	private function setInterestStats (
		$interestNum	// I: interest number
	) {
		// set the site stats if not already set
		$this->setSiteStats();

		$numUsers = $this->cache->get("interestnum-$interestNum");
		if ($numUsers === false) {
			$result = $this->masterdb->prepare_query("SELECT users FROM masterintereststats WHERE id = #", $interestNum);
			$numUsers = $result->fetchfield();
			$this->cache->put("interestnum-$interestNum", $numUsers, 86400);
		}

		$usersTotal = $this->siteStats['userstotal'];
		$factorValue = Array();
		$factorValue[] = $numUsers;
		$factorValue[] = ($usersTotal ? (double)$numUsers/$usersTotal : 0);
		$factorValue['desc'] = "setInterestStats ==> interestNum: $interestNum, usersTotal: $usersTotal";
		$this->debug("STATS", $factorValue['desc']);
		$this->debug("STATS", "                     matchingUsers: $numUsers/$factorValue[1]");
		$this->factors['interest'] = $factorValue;

	}

	private function setOnlineStats () {
		// set the site stats if not already set
		$this->setSiteStats();

		$usersTotal = $this->siteStats['userstotal'];
		$onlineUsers = $this->siteStats['onlineusers'];

		$factorValue = Array();
		$factorValue[] = $onlineUsers;
		$factorValue[] = ($usersTotal ? (double)$onlineUsers/$usersTotal : 0);
		$factorValue['desc'] = "setOnlineStats ==> $onlineUsers out of $usersTotal users online";
		$this->debug("STATS", $factorValue['desc']);
		$this->debug("STATS", "                   matchingUsers: $onlineUsers/$factorValue[1]");
		$this->factors['online'] = $factorValue;

	}
	/* END SET FACTOR/STATS METHODS */


	/* BEGIN DB/MEMCACHE SET METHODS */

	/* SYNOPSIS
	 * These methods are used internally by the class to get data from the database, and place the results in memcache
	 * as well as storing the values into a property within the object
	 * END SYNOPSIS */

	/* HISTORY
	 * Created June 14, 2006 by pdrapeau
	 * END HISTORY */
	private function setUidSearchRange () {
		if ($this->uidSearchRange !== false)
			return true;

		// figure out what the userid search ranges are in the databases, checking memcache for values first
		$uidSearchRange = $this->cache->get("usersearch-id-ranges");

		if ($uidSearchRange === false) {
			$uidSearchRange = Array();
			$results = $this->masterdb->prepare_query("SELECT serverid, startid, endid FROM usersearchidrange");
			while ($row = $results->fetchrow()) {
				if ($row['startid'] > 0 && $row['endid'] > 0)
				$uidSearchRange[$row['serverid']] = Array('startid' => $row['startid'], 'endid' => $row['endid']);
			}
			$this->cache->put("usersearch-id-ranges", $uidSearchRange, 3600*24);
		}

		$this->uidSearchRange = $uidSearchRange;
		return true;
	}
	/* END DB/MEMCACHE SET METHODS */


	/* METHOD: search */

	/* SYNOPSIS
	 * This method performs the search once the search parameters have been set, and returns a userSearchResults object
	 * END SYNOPSIS */

	/* HISTORY
	 * Created May 30, 2006 by pdrapeau
	 * END HISTORY */
	function search () {
		Array('search','start');
		// in debug mode, setup a timer on this method
		$this->debug("EXECPROFILE", '', array('search','start'));
		$this->debug("EXECPROFILE", '', array("search", "lap", "[init timer] done --> start sanity checks"));

		// deal with parameters that may be passed to search, parameter count must match whats defined, or have one extra
		// parameter in addition to specify if we're getting user data for the result set
		if ((count($this->searchParams[$this->resultType]) != func_num_args()) && (count($this->searchParams[$this->resultType]) + 1 != func_num_args()))
			trigger_error("userSearch->search: incorrect parameter count for resultType $this->resultType (got ".func_num_args()." expected ".count($this->searchParams[$this->resultType])." and getUserData)", E_USER_ERROR);


		// now grab the parameters in the order their specified, and set the corresponding properties in the object
		foreach ($this->searchParams[$this->resultType] as $argNum => $argName) {
			$this->{$argName} = func_get_arg($argNum);
		}

		// now set if we're getting user data for the result set, which comes from the last parameter to the function
		// if it has been provided, otherwise default to true
		if (count($this->searchParams[$this->resultType]) + 1 == func_num_args())
			$getUserData = func_get_arg(func_num_args()-1);
		else
			$getUserData = true;

		// check to see if we're trying to get a random page from a search that doesn't suppport random results
		if ($this->resultType == "LIST" && $this->pageNumber === false && in_array("RAND", $this->validResultTypes[$this->searchType]) === false)
			$this->pageNumber = 1;

		// check if getUserData is of type bool
		if (!is_bool($getUserData))
			trigger_error("userSearch->search: parameter getUserData must be of type BOOL", E_USER_ERROR);

		// make sure required parameters for the search and result types are now set
		if (isset($this->requiredPropSearch[$this->searchType]) && is_array($this->requiredPropSearch[$this->searchType]))
			foreach ($this->requiredPropSearch[$this->searchType] as $key => $requiredProp)
				if (!isset($this->{$requiredProp}))
					trigger_error("userSearch->search: required parameter ($requiredProp) for search type $this->searchType is not set", E_USER_ERROR);

		if (isset($this->requiredPropResult[$this->resultType]) && is_array($this->requiredPropResult[$this->resultType]))
			foreach ($this->requiredPropResult[$this->resultType] as $key => $requiredProp)
				if (!isset($this->{$requiredProp}))
					trigger_error("userSearch->search: required parameter ($requiredProp) for result type $this->resultType is not set", E_USER_ERROR);

		$this->debug("EXECPROFILE", '', array("search", "lap", "[sanity checks] done --> start query"));

		// execute module for ALL_USERS search type (this is a one off)
		if ($this->searchType == "ALLUSERS")
			$resultSet = $this->queryAllUsers();

		// execute search methods for result sets of type LIST
		if ($this->resultType == "LIST")
			$resultSet = $this->execSearchMethods();

		// execute search methods for result sets of type RAND
		if ($this->resultType == "RAND" && $this->searchType != "ALLUSERS")
			$resultSet = $this->execRandomSearch();

		// if resultSet is set to false, there are no results, thus re-set the object properties and return false
		if ($resultSet === false) {
			$this->debug("EXECPROFILE", '', array("search", "done", "[query] done -> no results -> search() has completed"));
			$resultObject = $this->createResultObject();
			$this->resetProperties();
			return $resultObject;
		}

		// create the result object
		$this->debug("EXECPROFILE", '', array("search", "lap", "[query] done --> create results object"));
		$resultObject = $this->createResultObject($resultSet);

		// now get the user data for the search
		$this->debug("EXECPROFILE", '', array("search", "lap", "[results object] created --> populate result data"));

		if ($getUserData == true) {
			call_user_func(array(&$resultObject, 'getUserData'));
		}

		// reset the per-search properties and than return the result object
		$this->debug("EXECPROFILE", '', array("search", "done", "[populate result data] done --> search() has completed"));
		$this->resetProperties();
		return $resultObject;
	}
	/* END METHOD search */


	/* METHOD: execRandomSearch */

	/* SYNOPSIS
	 * This method executes execSearchMethods() as many times as needed to get the required number of results for
	 * a random search
	 * END SYNOPSIS */

	/* HISTORY
	 * Created Jun 13, 2006 by pdrapeau
	 * END HISTORY */
	private function execRandomSearch () {
		// init resultSet array and resultsToGet
		$resultSet = Array();
		$resultsToGet = $this->numRandReturned;
		$maximumQueries = $this->maxRandAttempt;
		$attemptedQueries = 0;

		// set the number of results per page to randPageSize, and the page number to false
		// and the result type to LIST
		$this->resultsPerPage = $this->randPageSize;
		$this->resultType = "LIST";
		$multiPage = true;

		// keep getting pages of random results as long as we don't have enough results
		// until we hit the maximum number of query attempts allowed
		while ($resultsToGet > 0 && ($attemptedQueries <= $maximumQueries)) {
			// get a random page of search results
			$this->pageNumber = false;
			$resultPage = $this->execSearchMethods();
			$resultPageCount = count($resultPage);
			// check to see if we're dealing with multiple pages of results (could cause duplicates)
			if ($attemptedQueries == 0 && ($this->resultsOnPage >= $resultsToGet))
				$multiPage = false;

			// if there are less results on the page than we need to get, simply append them
			// to the result set array (thus using the entire page of results) otherwise pick some
			// random values out of the page of results, if no results are returned period, don't bother
			// to re-query just return false
			if ($resultPageCount <= $resultsToGet && $resultPage !== false) {
				$resultSet = array_merge ($resultSet, $resultPage);
				$resultsToGet = $resultsToGet - $this->resultsOnPage;
			} else if ($resultPage !== false) {
				randomize();
				if ($resultsToGet > 1) {
					$randomKeys = array_rand($resultPage, $resultsToGet);
					foreach ($randomKeys as $pageKey) {
						$resultSet[] = $resultPage[$pageKey];
						$resultsToGet--;
					}
				} else {
					$randomKey = rand(0, $resultPageCount - 1);
					$resultSet[] = $resultPage[$randomKey];
					$resultsToGet--;
					$multiPage = false;
				}
			} else {
				return false;
			}

			// remove any duplicates from result set, and update number of results left to get (if we're dealing with
			// more than one page of results)
			if ($multiPage === true) {
				$resultSetCount = count($resultSet);
				$resultSet = array_unique($resultSet);
				$resultSetCountUnique = count($resultSet);
				$difference = $resultSetCount - $resultSetCountUnique;
				$resultsToGet = $resultsToGet + $difference;
			}

			$attemptedQueries++;
		}

		// re-set result type to rand, re-index array and count the results and return
		if ($multiPage === true)
			$resultSet = array_merge($resultSet);
		$this->resultType = "RAND";
		$this->totalResults = count($resultSet);
		return $resultSet;
	}
	/* END METHOD execRandomSearch */


	/* METHOD: execSearchMethods */

	/* SYNOPSIS
	 * This method executes the actual search methods and is called by search()
	 * END SYNOPSIS */

	/* HISTORY
	 * Created Jun 13, 2006 by pdrapeau
	 * END HISTORY */
	private function execSearchMethods () {
		// first call the prequery method for this search type if it has been defined
		$this->debug("EXECPROFILE", '', array("execSearchMethods", "start"));
		$this->debug("EXECPROFILE", '', array("execSearchMethods", "lap", "[init timer] done --> call prequery method"));
		if ($this->prequeryMethods[$this->searchType]) {
			$prequeryMethodParams = $this->prequeryMethods[$this->searchType];
			$prequeryMethodName = array_shift($prequeryMethodParams);

			// if prequery method returns false, there are no results and no need to run the query
			// thus return false
			if (!call_user_func_array(array(&$this, $prequeryMethodName), $prequeryMethodParams)) {
				$this->debug("EXECPROFILE", '', array("execSearchMethods", "done", "[prequery method] done --> no results -> execSearchMethods() done"));
				return false;
			}
			// at this point, we know how many pages are in the result set, thus we can auto-generate a random page number
			// if it has been requested (and not as of yet set)
			if ($this->resultType == "LIST" && $this->numberOfPages !== false && $this->pageNumber === false) {
				randomize();
				$this->pageNumber = rand(1,$this->numberOfPages);
				$this->debug("INFO", "[RANDOM PAGE] Page Number ".$this->pageNumber." has been selected");
			}

			// if for some reason the page number ends up being greater than the requested page number at this point,
			// than re-set the page number to 1, this is to avoid a re-query (only done if we actually know the total
			// number of pages at this point, which we should in most cases)
			if ($this->pageNumber !== false && $this->numberOfPages !== false && ($this->pageNumber > $this->numberOfPages))
				$this->pageNumber = 1;

		}

		// now call the query method for this search type, which will perform the actual query
		$this->debug("EXECPROFILE", '', array("execSearchMethods", "lap", "[prequery method] done --> call query method"));
		if ($this->queryMethods[$this->searchType]) {
			$queryMethodParams = $this->queryMethods[$this->searchType];
			$queryMethodName = array_shift($queryMethodParams);
			$resultSet = call_user_func_array(array(&$this, $queryMethodName), $queryMethodParams);
		} else {
			trigger_error("execSearchMethods->search: no query method has been defined for $this->searchType", E_USER_ERROR);
		}

		// if we're in list mode, check to see that the requested page number is not greater than the total number of
		// pages once again, this is to catch any cases where the actual query method is the only place where we actually
		// determine the number of pages in the result set (only called if there actually are results in the result set)
		if ($this->resultType == "LIST" && ($this->numberOfPages > 0) && ($this->pageNumber > $this->numberOfPages)) {
			$this->pageNumber = 1;
			$resultSet = call_user_func_array(array(&$this, $queryMethodName), $queryMethodParams);
		}

		// if theres no results from the query for this page, return false here, and set total results to 0 as well
		// since theres apparently no results
		if ($this->resultsOnPage < 1) {
			$this->totalResults = 0;
			$this->debug("EXECPROFILE", '', array("execSearchMethods", "done", "[query method] execSearchMethods() done"));
			return false;
		}

		// return the result set
		$this->debug("EXECPROFILE", '', array("execSearchMethods", "done", "[query method] execSearchMethods() done"));
		return $resultSet;
	}
	/* METHOD execSearchMethods */


	/* METHOD: queryNewUsers */

	/* SYNOPSIS
	 * This method performs the query for new users in the system
	 * END SYNOPSIS */

	/* HISTORY
	 * Created May 30, 2006 by pdrapeau
	 * END HISTORY */
	private function queryNewUsers () {
		global $cache;

		$queryParts = Array();
		$queryParams = Array();
		$mcparams = array();
		$query = "SELECT userid FROM newestusers";
		$queryParams[0] = &$query;

		if (!$this->sex && $this->ageRange) {
			$queryParts[0] = "sex IN (?)";
			$queryParams[1] = array('Male', 'Female');
			$mcparams[0] = 'sex:all';
		}

		if ($this->sex) {
			$queryParts[0] = "sex = ?";
			$queryParams[1] = $this->sex;
			$mcparams[0] = "sex:{$this->sex}";
		}

		if ($this->ageRange) {
			$queryParts[] = "age IN (#)";
			$queryParams[] = $this->ageRange;
			$mcparams[] = 'age:' . implode(',', $this->ageRange);
		}

		if ($this->ageRange || $this->sex)
			$query .= " WHERE " . implode(" && ", $queryParts);

		$cachekey = 'search-new-user-' . implode('-', $mcparams);

		$query .= " ORDER BY userid DESC LIMIT $this->resultsPerPage";

		if (!($resultSet = $cache->get($cachekey)))
		{
			$query = call_user_func_array(Array(&$this->generaldb, 'prepare'), $queryParams);

			$this->debug("SQL", array('[QUERY]',$query));

			$queryResult = call_user_func_array(Array(&$this->generaldb, 'query'), $query);

			$resultSet = Array();
			while($row = $queryResult->fetchrow())
				$resultSet[] = $row['userid'];

			$cache->put($cachekey, $resultSet, 30);
		}

		$this->totalResults = count($resultSet);
		$this->resultsOnPage = count($resultSet);
		$this->numberOfPages = ceil($this->totalResults / $this->resultsPerPage);

		return $resultSet;
	}
	/* END METHOD queryNewUsers */


	/* METHOD: queryBdayUsers */

	/* SYNOPSIS
	 * This method performs the search for users whose b-day is today
	 * END SYNOPSIS */

	/* HISTORY
	 * Created May 30, 2006 by pdrapeau
	 * END HISTORY */
	private function queryBdayUsers () {
		$queryParts = Array();
		$queryParams = Array();
		$query = "SELECT SQL_CALC_FOUND_ROWS userid FROM bday";
		$queryParams[0] = &$query;

		if (!$this->sex && $this->ageRange) {
			$queryParts[0] = "sex IN (?)";
			$queryParams[1] = array('Male', 'Female');
		}

		if ($this->sex) {
			$queryParts[0] = "sex = ?";
			$queryParams[1] = $this->sex;
		}

		if ($this->ageRange) {
			$queryParts[] = "age IN (#)";
			$queryParams[] = $this->ageRange;
		}

		if ($this->ageRange || $this->sex)
			$query .= " WHERE " . implode(" && ", $queryParts);

		$offsetMultiplier = $this->pageNumber - 1;

		$query .= " ORDER BY userid DESC LIMIT " . ($offsetMultiplier*$this->resultsPerPage) . ", $this->resultsPerPage";

		$query = call_user_func_array(Array(&$this->generaldb, 'prepare'), $queryParams);

		$this->debug("SQL", array('[QUERY]',$query));

		$queryResult = call_user_func_array(Array(&$this->generaldb, 'query'), $query);
		$resultSet = Array();
		while($row = $queryResult->fetchrow())
			$resultSet[] = $row['userid'];

		$this->totalResults = $queryResult->totalrows();
		$this->resultsOnPage = count($resultSet);
		$this->numberOfPages = ceil($this->totalResults / $this->resultsPerPage);

		return $resultSet;
	}
	/* END METHOD queryBdayUsers */


	/* METHOD: buildQueryParts */

	/* SYNOPSIS
	 * This method builds an SQL query from the query parts array and returns it
	 * END SYNOPSIS */

	/* HISTORY
	 * Created May 30, 2006 by pdrapeau
	 * END HISTORY */
	private function buildQueryParts (
			$queryParts			// I: query parts array
	) {
		$stringParts = Array();
		$queryVars = Array();

		$queryString = "FROM ";
		$queryVars[] = &$queryString;

		// build the from clause in the SQL query
		$tables = implode(", ", array_keys($queryParts['tables']));
		$this->debug("SQL", "[QUERY TABLES] ".$tables);
		$queryString .= $tables." WHERE ";

		// build the where clause in the SQL query for cols we are querying on
		$priority = 1;
		foreach ($queryParts['tables'] as $tableName => $cols) {
			foreach ($cols as $colName => $params) {
				if (isset($params['PRIORITY'])) {
					$itemPriority = $params['PRIORITY'];
				} else {
					$itemPriority = $priority;
					$priority++;
				}
				// figure out the place holder for the query part
				if (isset($params['VALUE']) && (is_integer($params['VALUE']) || is_array($params['VALUE']) && is_integer($params['VALUE'][0])))
					$placeHolder = "#";
				else
					$placeHolder = "?";
				// set the col to query on, including the table name
				$stringPart = $tableName.'.'.$colName;

				switch($params['TYPE']) {
					case 'IN':
						$stringPart .= ' IN ('.$placeHolder.')';
						$queryVars[$itemPriority] = $params['VALUE'];
						break;
					case 'EQUALS':
						$stringPart .= ' = '.$placeHolder;
						$queryVars[$itemPriority] = $params['VALUE'];
						break;
					case 'RANGE':
						$stringPart .= " BETWEEN # AND #";
						$queryVars[$itemPriority] = $params['MIN'];
						$queryVars[$itemPriority+1] = $params['MAX'];
						$priority++;
						break;
					case 'LIKE':
						$stringPart .= " LIKE ".$placeHolder;
						$queryVars[$itemPriority] = $params['VALUE'];
						break;
					default:
						$stringPart .= " ".$params['TYPE']." ".$placeHolder;
						$queryVars[$itemPriority] = $params['VALUE'];
						break;
				}
				$stringParts[$itemPriority] = $stringPart;
			}
		}

		// now build the where clause for tables we are joining on
		if (isset($queryParts['join'])) {
			$reletiveTo = $queryParts['join']['RELETIVE_TO'];
			foreach ($queryParts['join']['JOIN_ON'] as $joinValues) {
				$stringParts[$priority] = $joinValues['TABLE'].'.'.$joinValues['COL'].' = '.$reletiveTo.'.'.$joinValues['COL'];
				$priority++;
			}
		}
		// sort the arrays
		ksort($stringParts);
		ksort($queryVars);

		// debug output
		if ($this->debug === true) {
			$debugOutput = "";
			foreach ($stringParts as $priority => $value) {
				$debugOutput .= "$priority => $value\n";
			}
			$this->debug("SQL", Array("[QUERY PARTS]", $debugOutput));
		}

		// implode the query string
		$queryString .= implode(" && ", $stringParts);

		// run the SQL query through prepare on usersdb
		$outputString = call_user_func_array(array(&$this->usersdb, 'prepare'), $queryVars);
		return $outputString;
	}
	/* END METHOD buildQueryParts */


	/* METHOD: queryUserSearch */

	/* SYNOPSIS
	 * This method performs searches against the user search table based on
	 * results from stats
	 * END SYNOPSIS */

	/* HISTORY
	 * Created May 30, 2006 by pdrapeau
	 * END HISTORY */
	private function queryUserSearch () {
		// init vars
		$queryRange = false;

		$this->debug("EXECPROFILE", '', array("queryUserSearch", "start"));
		$this->debug("EXECPROFILE", '', array("queryUserSearch", "lap", "[init timer] done --> start build query"));

		// get the count of tables in the query
		$tableCount = count($this->queryParts['tables']);

		if ($tableCount < 1)
			trigger_error("userSearch->queryUserSearch: there are no tables in the query!", E_USER_ERROR);


		// if there are more than one tables involved in the query, set what field(s) we will be joining on
		// in this case, it will be user id
		if ($tableCount > 1) {
			$joinTables = array_keys($this->queryParts['tables']);
			$reletiveTo = array_shift($joinTables);
			$joinTo = Array();
			foreach($joinTables as $tableName)
				$joinTo[] = array('TABLE' => $tableName, 'COL' => 'userid');

			$this->queryParts['join'] = Array (	'RELETIVE_TO'	=> $reletiveTo,
												'JOIN_ON'		=> $joinTo);
		}

		// build the main part of the query used in all cases as the base for the query
		$queryStrings = Array();
		$queryStrings['all'] = "SELECT usersearch.userid ";
		$queryStrings['all'] .= $this->buildQueryParts($this->queryParts);

		$this->debug("EXECPROFILE", '', array("queryUserSearch", "lap", "[build query] done --> start run query"));

		// okay figure out what ranges of UIDs we will be querying for, if we actually have stats set for the number
		// of results and pages, otherwise query for all records in the users database
		if ($this->pageNumber && $this->numberOfPages) {
			$this->debug("EXECPROFILE", '', array("queryUserSearch", "lap", "page numbers existing -> get user id search ranges"));
			$usersTotal = $this->siteStats['userstotal'];
			$pageNumber = $this->pageNumber;
			$numberOfPages = $this->numberOfPages;

			$queryMinId = (int)floor($usersTotal*($pageNumber-1)/$numberOfPages)+1;
			$queryMaxId = (int)ceil($usersTotal*$pageNumber/$numberOfPages);

			// figure out what the userid search ranges are in the databases
			$this->setUidSearchRange();
			$uidSearchRange = $this->uidSearchRange;
			$this->debug("EXECPROFILE", '', array("queryUserSearch", "lap", "[get ranges] done -> get db ranges"));

			// now figure out which database(s) the query is going to go against.
			$queryDbs = Array();
			foreach ($uidSearchRange as $databaseId => $range) {
				$rangeStart = $range['startid'];
				$rangeEnd = $range['endid'];

				$this->debug("SQL","[DB ID RANGE] [$databaseId] $rangeStart-$rangeEnd");

				// if this matches no need to go through the rest
				if ($queryMinId >= $rangeStart && $queryMaxId <= $rangeEnd) {
					$queryDbs[$databaseId] = true;
					break;
				}

				if ($queryMinId <= $rangeEnd && $queryMaxId > $rangeEnd)
					$queryDbs[$databaseId] = true;

				if ($queryMaxId >= $rangeStart && $queryMinId < $rangeStart)
					$queryDbs[$databaseId] = true;
			}
			$queryDbs = array_keys($queryDbs);
			$this->debug("SQL","[SEARCH ID RANGE] ".$queryMinId."-".$queryMaxId." -> Querying user db(s) ".implode(", ", $queryDbs));
			$this->debug("EXECPROFILE", '', array("queryUserSearch", "lap", "[db ranges] done -> figure out ranges against db"));
			// okay next we need to figure out if the query is going against multiple databases, and if so
			// it should be broken down into queries that query only for the specific range on each database
			$rangeQueryParts = Array();
			foreach ($queryDbs as $dbId) {
				$dbRange = Array();
				$rangeStart = $uidSearchRange[$dbId]['startid'];
				$rangeEnd = $uidSearchRange[$dbId]['endid'];
				if ($queryMinId <= $rangeEnd && $queryMaxId > $rangeEnd) {
					$dbRangeStart = $queryMinId;
					$dbRangeEnd = $rangeEnd;
				}

				if ($queryMaxId >= $rangeStart && $queryMinId <  $rangeStart) {
					$dbRangeStart = $rangeStart;
					$dbRangeEnd = $queryMaxId;
				}

				if ($queryMinId >= $rangeStart && $queryMaxId <= $rangeEnd) {
					$dbRangeStart = $queryMinId;
					$dbRangeEnd = $queryMaxId;
				}

				$rangePart = $this->usersdb->prepare("usersearch.id BETWEEN # AND #", $dbRangeStart, $dbRangeEnd);
				$queryStrings[$dbId] = $queryStrings['all']." && ".$rangePart;
			}
			unset($queryStrings['all']);
			$queryRange = true;
			$this->debug("EXECPROFILE", '', array("queryUserSearch", "lap", "[ranges against db] done -> step out of if statement"));
		}

		$this->debug("EXECPROFILE", '', array("queryUserSearch", "lap", "[check range] done -> run explain in debug mode"));
		// do explain output on the query string if debug is enabled
		if ($this->debug === true) {
			$this->debug("EXECPROFILE", '', array("USERSEARCHEXPLAIN", "start"));
			$this->debug("EXECPROFILE", '', array("USERSEARCHEXPLAIN", "lap", "[init timer] done -> start query loop"));
			foreach ($queryStrings as $dbId => $queryString) {
				if ($dbId == "all") {
					$dbInstance = $this->usersdb;
					$databaseName = "ALL";
				} else {
					$dbInstance = $this->usersdb->dbs[$dbId-1];
					$databaseName = $dbInstance->selectdb->dbname;
					$databaseName = "DB $dbId - $databaseName";
				}

				$this->debug("SQL", Array("[QUERY STRING] [$databaseName]", $queryString));
				$this->debug("EXECPROFILE", '', array("USERSEARCHEXPLAIN", "lap", "[query loop] -> start run query"));
				$results = $dbInstance->query("EXPLAIN ".$queryString);
				$this->debug("EXECPROFILE", '', array("USERSEARCHEXPLAIN", "lap", "[run query] done -> start fetch results"));
				$explainResults = "";
				while ($explainRow = $results->fetchrow())
					foreach ($explainRow as $field => $info) {
						$explainResults .= "$field => $info\n";
					}
				$this->debug("EXECPROFILE", '', array("USERSEARCHEXPLAIN", "lap", "[fetch results] done -> done query loop"));
				$this->debug("SQL", Array("[EXPLAIN] [$databaseName]", $explainResults));
			}
			$this->debug("EXECPROFILE", '', array("USERSEARCHEXPLAIN", "done", "done -> explain completed"));
		}
		$this->debug("EXECPROFILE", '', array("queryUserSearch", "lap", "[explain in debug] done -> run query"));

		// init vars used in queries
		$resultSet = Array();

		// deal with queries where a range is set
		if ($queryRange === true) {
			foreach ($queryDbs as $dbid) {
				$dbInstance = $this->usersdb->dbs[$dbid-1];
				$databaseName = $dbInstance->selectdb->dbname;
				if ($this->debug === true) {
					$startTime = microtime(true);
					$results = $dbInstance->query($queryStrings[$dbid]);
					$endTime = microtime(true);
					$diff = $endTime - $startTime;
					$diff = number_format($diff*1000, 3);
					$this->debug("SQL", "[QUERY TIME] [DB $dbid - $databaseName] $diff"."ms");
				} else {
					$results = $dbInstance->query($queryStrings[$dbid]);
				}
				while ($row = $results->fetchrow())
					$resultSet[] = $row['userid'];
			}

			// update counts of results
			$this->resultsOnPage = count($resultSet);

			// return the result set at this point with no further processing, since we know
			// what the paging will be for these results
			$this->debug("EXECPROFILE", '', array("queryUserSearch", "done", "[run query] done --> queryUserSearch() has completed"));
			return $resultSet;
		}


		// deal with queries where a range is not set, we handle this by simply
		// sending the queries to all instances of the users database
		if ($this->debug === true) {
			$startTime = microtime(true);
			$results = $this->usersdb->query($queryStrings['all']);
			$endTime = microtime(true);
			$diff = $endTime - $startTime;
			$diff = number_format($diff*1000, 3);
			$this->debug("SQL", "[QUERY TIME] [ALL] $diff"."ms");
		} else {
				$results = $this->usersdb->query($queryStrings['all']);
		}

		// build result set from whats returned from the databases
		while ($row = $results->fetchrow()) {
			$resultSet[] = $row['userid'];
		}

		// figure out the counts for the result set
		$this->totalResults = count($resultSet);
		$this->resultsInRetSet = $this->totalResults;
		$this->numberOfPages = ceil($this->totalResults / $this->resultsPerPage);
		$arrayEndIdx = $this->totalResults - 1;


		// now that we know that, we can deal with random page selections for this type of result set
		if ($this->pageNumber === false)
			$this->pageNumber = rand(1,$this->numberOfPages);

		// if we exceed the number of pages in the result set, set the page number back to 1
		if ($this->pageNumber > $this->numberOfPages)
			$this->pageNumber = 1;

		// figure out where in the array we start and end for the requested page
		$pageStartIdx = ($this->pageNumber - 1)*$this->resultsPerPage;
		$pageEndIdx = ($pageStartIdx + $this->resultsPerPage) - 1;

		// figure out how many results there should be on the current page
		if ($pageEndIdx > $arrayEndIdx) {
			$pageEndIdx = $arrayEndIdx;
		}

		// set results on page, and the start and end indexes in the array
		$this->resultsOnPage = ($pageEndIdx - $pageStartIdx) + 1;
		$this->pageStartIdx = $pageStartIdx;
		$this->pageEndIdx = $pageEndIdx;
		$this->debug("EXECPROFILE", '', array("queryUserSearch", "done", "[run query] done --> queryUserSearch() has completed"));
		return $resultSet;
	}
	/* END METHOD queryUserSearch */


	/* METHOD: prequeryUserSearch */

	/* SYNOPSIS
	 * This method sets up the query params for UserSearch, as well as getting stats based on the search params
	 * it is used for both the basic user search as well as the advanced user search since the queries
	 * are identicle
	 * END SYNOPSIS */

	/* HISTORY
	 * Created May 30, 2006 by pdrapeau
	 * END HISTORY */
	private function prequeryUserSearch (
		$usesStats	= true	// I: true/false search uses stats
	) {
		// check if the prequery has been ran for this search yet
		if ($this->prequeryRan === true)
			return true;

		// define the columns in the user search table, and the vars in the current scope they match up with
		// expecting that if the var is not part of the query, it will be set to false
		$cols = array (	'age'		=> 'ageRange',
						'sex'		=> 'sex',
						'loc'		=> 'location',
						'active'	=> 'activity',
						'pic'		=> 'pictures',
						'single'	=> 'singleUsersOnly',
						'sexuality'	=> 'sexuality');


		// query memcache, than the database for indexes on the usersearch table
		// presently the first users database will be used to get the list of indexes

		$indexes = $this->cache->get("usersearch-table-indexes");

		if ($indexes == false) {
			$dbInstances = $this->usersdb->getSplitDBs();
			if (!isset($dbInstances[0]))
				trigger_error("userSearch->prequeryUserSearch: no first instance of users database, cannot get indexes", E_USER_ERROR);

			$indexes = array();
			$result = $dbInstances[0]->prepare_query("SHOW INDEX FROM usersearch");
			while($row = $result->fetchrow()) {
				$keyName = $row['Key_name'];
				$colName = $row['Column_name'];
				if (!isset($indexes[$keyName]))
					$indexes[$keyName] = Array();
				$indexes[$keyName][$colName] = true;
			}
			if (isset($indexes['PRIMARY']))
				unset ($indexes['PRIMARY']);

			if (isset($indexes['userid']))
				unset ($indexes['userid']);

			$this->cache->put("usersearch-table-indexes", $indexes, 3600*24);
		}

		// if we're in debug mode, show the indexes we can pick from
 		if ($this->debug === true) {
 			$debugMsg = "";
 			foreach ($indexes as $indexName => $indexCols) {
 				$debugMsg .= "[$indexName] ";
 				$debugMsg .= join(", ", array_keys($indexCols))."\n";
 			}
 			$debugMsg = rtrim($debugMsg,"\n");
 			$this->debug("SQL", Array("[INDEXES]", $debugMsg));
 		}

 		// check to see if we're searching by partial username match, and if so stats cannot be used
		if ($this->unameType && $this->uname)
			$usesStats = false;

 		// now figure out what is going to be in the query, and build an array keyed by col name containing
 		// the data which will be used in the where clause, if we're generating stats for the query, build the array
 		// of params used to generate the stats
 		$queryVars = array();
 		$queryStats = array();
 		$debugMsg = "";
 		foreach ($cols as $colName => $varName) {
 			if ($this->{$varName}) {
 				if ($this->debug === true)
					 $debugMsg .= $colName." ";

				if (is_array($this->{$varName}))
					$paramType = 'IN';
				else
					$paramType = 'EQUALS';

				$queryPart = Array('TYPE' => $paramType, 'VALUE' => $this->{$varName});
				$queryVars[$colName] = $queryPart;

 				if ($usesStats === true)
 					$queryStats[$colName] = true;

 			} else if ($usesStats === true)
 				$queryStats[$colName] = false;
 		}

 		if ($this->debug === true && $debugMsg == "")
 			$debugMsg = "**NONE**";
		$this->debug("SQL", "[QUERY COLS] -> ".$debugMsg);

		// append id on to the array of col names, since all searches do rely on the ID range, however set it to false
		// since it won't be used to form the query here
		$queryVars['id'] = false;


		// now check and see which indexes could be used for the query, getting counts of how many fields in the index match
		// fields in the query, the total counts, and what the difference is
		$indexMatch = Array();
		$indexMatchMax = 0;
		foreach($indexes as $indexName => $indexCols) {
			$keyMatch = array_intersect_key($queryVars, $indexCols);
			$numMatched = count($keyMatch);
			if ($numMatched > $indexMatchMax)
				$indexMatchMax = $numMatched;
			$indexMatch[$indexName] = $numMatched;
		}


		// okay now figure out the indexes that match the maxiumum number of fields, placing the difference in the number
		// of fields between the index and the counts they matched as the value
		$mostIndexesMatched = Array();
		foreach ($indexMatch as $indexName => $numMatched)
			if ($numMatched == $indexMatchMax)
				$mostIndexesMatched[$indexName] = count($indexes[$indexName]) - $numMatched;

		// okay, we want to attempt to form the query so the index that uses the most matching parts of the query is used
		// while at the same time also using the one with the least additional componants that need to be added in order to be
		// able to use the index
		foreach ($mostIndexesMatched as $indexName => $numFieldsDiff) {
			if (!isset($minNumFieldsDiff) || ($numFieldsDiff < $minNumFieldsDiff)) {
				$minNumFieldsDiff = $numFieldsDiff;
				$usedIndex = $indexName;
			}
		}

		// print out the used index if debug is enabled
		$this->debug("SQL", "[TARGET IDX] -> $usedIndex");

		// okay now that we know which index is probablly going to get used, figure out what params are missing, and thus
		// must have all permissable values filled in for the index to be used
		$missingCols = array_diff_key($indexes[$usedIndex], $queryVars);
		foreach ($missingCols as $colName => $value) {
			switch ($colName) {
				case 'age':
					$value = range($this->ageMin,$this->ageMax);
					break;
				case 'sex':
					$value = array('Male','Female');
					break;
				case 'loc':
					$value = $this->getSubLocs();
					break;
				case 'active':
					$value = range(0,2);
					break;
				case 'pic':
					$value = range(0,2);
					break;
				case 'single':
					$value = range(0,1);
					break;
				case 'sexuality':
					$value = range(0,3);
					break;
			}
			$queryPart = Array('TYPE' => 'IN', 'VALUE' => $value);
			$queryVars[$colName] = $queryPart;
		}

		// remove ID from the $queryVars array, as its no longer needed here
		unset($queryVars['id']);

		// okay now if stats are to be used for this query, set the stats values
		if ($usesStats === true) {
			// set the site stats if not already set
			$this->setSiteStats();

			// set initial stats for age and sex
			if ($queryStats['sex'] === true || $queryStats['age'] === true)
				$this->setAgeSexStats($this->sex, $this->startAge, $this->endAge);

			// set stats for location
			if ($queryStats['loc'] === true)
				$this->setLocStats($this->location);

			// set stats for activity level and pictures
			if ($queryStats['active'] === true || $queryStats['pic'] === true) {
				$ageSexCol = "";
				if ($this->activity == 1)
					$ageSexCol .= "active";

				if ($this->pictures == 1)
					$ageSexCol .= "pics";
				else if ($this->pictures == 2)
					$ageSexCol .= "signpics";

				// if the col is still blank at this point, user must be searching for online users
				// without querying for pics, or signpics
				if ($ageSexCol != "")
					$this->setAgeSexStats($this->sex, $this->startAge, $this->endAge, $ageSexCol);

				// if searching for online users, simply set the online stats
				if ($this->activity == 2)
					$this->setOnlineStats();
			}

			// set stats for single
			if ($queryStats['single'] === true)
				$this->setAgeSexStats($this->sex, $this->startAge, $this->endAge, 'single');

			// set stats for sexuality
			if ($queryStats['sexuality'] === true)
				$this->setAgeSexStats($this->sex, $this->startAge, $this->endAge, 'sexuality'.$this->sexuality);

			// set stats for user interest
			if ($this->interest != false)
				$this->setInterestStats($this->interest);

			// check to insure that there are factors present, otherwise we're assuming its the entire userbase
			if (count($this->factors) > 0) {
				// okay calculate the overall factor now
				$overallFactor = 1.0;
				$factorDebug = "";
				foreach($this->factors as $factorName => $factor) {
					$factorDebug .= "[$factorName] -> $factor[1]\n";
					$overallFactor *= $factor[1];
				}

				// now figure out number of users which should match
				$estimatedResults = ceil($this->siteStats['userstotal'] * $overallFactor);

				$factorDebug .= "[FACTOR AVERGE] => $overallFactor  ***$estimatedResults user(s) estimated";
				$this->debug("STATS", Array('[FACTORS]', $factorDebug));
			} else {
				$this->debug("STATS", "[NOTICE] No factors for query, assuming entire user base (".$this->siteStats['userstotal']." users)");
				$estimatedResults = $this->siteStats['userstotal'];
			}

			// set result count, pages, etc based on stats
			$this->totalResults = $estimatedResults;
			$this->numberOfPages = ceil($this->totalResults/$this->resultsPerPage);
			$this->resultsOnPage = floor(($this->numberOfPages ? (double)$this->totalResults/$this->numberOfPages : 0));

			$this->debug("STATS", "[EST RESULTS] => Total: $this->totalResults, Pages: $this->numberOfPages, Averge/Requested Per Page: $this->resultsOnPage/$this->resultsPerPage");

			// if there are 0 users estimated at this point, we can just simply return without worrying
			// about the query
			if ($this->totalResults < 1)
				return false;
		}

		// expand active, pic, and loc to include some logical additional values depending on the selection
		// -searching for users who are active recently should also include online users
		// -searching for users who have a pic, should also include users with verified pictures
		// -searching in a location should include all locations under it in the tree

		//active
		if (isset($queryVars['active']) && $queryVars['active']['VALUE'] == 1) {
			$queryVars['active']['TYPE'] = 'IN';
			$queryVars['active']['VALUE'] = range(1,2);
		}

		// pic
		if (isset($queryVars['pic']) && $queryVars['pic']['VALUE'] == 1) {
			$queryVars['pic']['TYPE'] = 'IN';
			$queryVars['pic']['VALUE'] = range(1,2);
		}

		//loc
		if (isset($queryVars['loc'])) {
			$queryVars['loc']['TYPE'] = 'IN';
			$queryVars['loc']['VALUE'] = $this->getSubLocs($queryVars['loc']['VALUE']);
		}

		// okay, now we can set queryParts to contain the usersearch part of the query
		$this->queryParts = Array();
		$this->queryParts['tables'] = Array();
		$this->queryParts['tables']['usersearch'] = $queryVars;

		// next if there is a user name specified in the query, it needs to be added to the array of query parts
		// this goes against the usernames table
		if ($this->unameType && $this->uname) {
			$queryPart = Array('username' => Array('TYPE' => 'LIKE'));
			switch($this->unameType) {
				case 'starts':
					$queryPart['username']['VALUE'] = $this->uname."%";
					break;
				case 'includes':
					$queryPart['username']['VALUE'] = "%".$this->uname."%";
					break;
				case 'ends':
					$queryPart['username']['VALUE'] = "%".$this->uname;
					break;
			}

			$this->queryParts['tables']['usernames'] = $queryPart;
		}

		// finally deal with interests if any have been given
		if ($this->interest) {
			$this->queryParts['tables']['userinterests'] = Array('interestid' => Array('TYPE' => 'EQUALS', 'VALUE' => $this->interest));
		}

		// set the prequery as having been ran
		$this->prequeryRan = true;

		return true;
	}
	/* END METHOD prequeryUserSearch */


	/* METHOD: querySpotLight */

	/* SYNOPSIS
	 * This method returns users in the spotlight history table
	 * END SYNOPSIS */

	/* HISTORY
	 * Created May 30, 2006 by pdrapeau
	 * END HISTORY */
	private function querySpotLight () {
		$queryParts = Array();
		$queryParams = Array();
		$query = "SELECT SQL_CALC_FOUND_ROWS DISTINCT userid, pic FROM spotlighthist WHERE time >= #";
		$queryParams[0] = &$query;
		$queryParams[1] = time() - 3600*2;

		$offsetMultiplier = $this->pageNumber - 1;

		$query .= " ORDER BY time DESC LIMIT " . ($offsetMultiplier*$this->resultsPerPage) . ", $this->resultsPerPage";

		$query = call_user_func_array(Array(&$this->generaldb, 'prepare'), $queryParams);

		$this->debug("SQL", array('[QUERY]',$query));

		$queryResult = call_user_func_array(Array(&$this->generaldb, 'query'), $query);
		$resultSet = Array();

		// result set here contains multiple values which have been passed from the database
		while($row = $queryResult->fetchrow()) {
			$resultSet[] = Array( 'userId' 	=> $row['userid'],
								  'picId' 	=> $row['pic']);
		}

		$this->totalResults = $queryResult->totalrows();
		$this->resultsOnPage = count($resultSet);
		$this->numberOfPages = ceil($this->totalResults / $this->resultsPerPage);
		return $resultSet;
	}
	/* END METHOD querySpotLight */


	/* METHOD: queryAllUsers */

	/* SYNOPSIS
	 * This method is just simply an efficient way to grab (multiple) random users from the database
	 * since it relies on simply figuring out the UID search range in one database instance
	 * and pickin random users from that database
	 * END SYNOPSIS */

	/* HISTORY
	 * Created Jun 14, 2006 by pdrapeau
	 * END HISTORY */
	private function queryAllUsers () {
		// first get the userid search ranges, and set the number of users to fetch
		$this->setUidSearchRange();
		$uidSearchRange = $this->uidSearchRange;
		$numUsers = $this->numRandReturned;

		// randomize
		randomize();

		// pick a random database
		$databaseId = array_rand($uidSearchRange, 1);
		$searchRange = $uidSearchRange[$databaseId];

		// set the start and end to the integer values from the search range table
		$rangeStart = intval($searchRange['startid']);
		$rangeEnd = intval($searchRange['endid']);


		// INIT array to hold random values, and number of values to 0
		$randomValues = Array();
		$numValues = 0;
		$repeate = false;


		// now grab some random numbers that are unique which fall into the range
		// for the randomly selected database
		for ($x = 0; $x < ceil($numUsers/2) && $numValues < $numUsers; $x++) {
			$valuePool = Array();
			for ($y=0; $y < ($numUsers * 2); $y++)
				$valuePool[] = rand($rangeStart, $rangeEnd);

			$valuePool = array_unique($valuePool);

			foreach ($valuePool as $value) {
				if ($repeate === true && in_array($value, $randomValues) === false) {
					$randomValues[] = $value;
				} else if ($repeate === false) {
					$randomValues[] = $value;
				}

				$numValues++;
				if ($numValues >= $numUsers)
					break;
			}
			$repeate = true;
		}


		// now query the user search table in the database instance
		$dbInstance = $this->usersdb->dbs[$databaseId-1];
		$results = $dbInstance->prepare_query("SELECT userid FROM usersearch WHERE id IN (#)", $randomValues);

		// fetch results
		$resultSet = Array();
		while ($row = $results->fetchrow())
			$resultSet[] = $row['userid'];

		return $resultSet;
	}
	/* END METHOD queryAllUsers */


	/* METHOD: queryNewProfile */

	/* SYNOPSIS
	 * This method queries the newest profile table to get users who have recently updated their profile
	 * END SYNOPSIS */

	/* HISTORY
	 * Created Jun 14, 2006 by pdrapeau
	 * END HISTORY */
	private function queryNewProfile () {
		global $cache;

		$queryParts = Array();
		$queryParams = Array();
		$mcparams = array();
		$query = "SELECT userid FROM newestprofile";
		$queryParams[0] = &$query;

		if (!$this->sex && $this->ageRange) {
			$queryParts[0] = "sex IN (?)";
			$queryParams[1] = array('Male', 'Female');
			$mcparams[0] = 'sex:all';
		}

		if ($this->sex) {
			$queryParts[0] = "sex = ?";
			$queryParams[1] = $this->sex;
			$mcparams[0] = "sex:{$this->sex}";
		}

		if ($this->ageRange) {
			$queryParts[] = "age IN (#)";
			$queryParams[] = $this->ageRange;
			$mcparams[] = 'age:' . implode(',', $this->ageRange);
		}

		if ($this->ageRange || $this->sex)
			$query .= " WHERE " . implode(" && ", $queryParts);

		$query .= " ORDER BY id DESC LIMIT $this->resultsPerPage";

		$cachekey = 'search-new-profile-' . implode('-', $mcparams);
		if (!($resultSet = $cache->get($cachekey)))
		{
			$query = call_user_func_array(Array(&$this->generaldb, 'prepare'), $queryParams);

			$this->debug("SQL", array('[QUERY]',$query));

			$queryResult = call_user_func_array(Array(&$this->generaldb, 'query'), $query);
			$resultSet = Array();
			while($row = $queryResult->fetchrow())
				$resultSet[] = $row['userid'];

			$cache->put($cachekey, $resultSet, 30);
		}

		$this->totalResults = count($resultSet);
		$this->resultsOnPage = count($resultSet);
		$this->numberOfPages = ceil($this->totalResults / $this->resultsPerPage);

		return $resultSet;
	}
	/* END METHOD queryNewProfile */


	/* METHOD: getSubLocs */

	/* SYNOPSIS
	 * This method returns an array of all locs in the config database
	 * END SYNOPSIS */

	/* HISTORY
	 * Created May 30, 2006 by pdrapeau
	 * END HISTORY */
	function getSubLocs (
			$location = false	// I: locid to get sublocs for, or false for all
	) {
		if ($this->locs === false) {
			if (!$this->locationsObj)
				$this->locationsObj = new category( $this->configdb, "locs");

			if ($location === false)
				$rootBranch = $this->locationsObj->makebranch();
			else
				$rootBranch = $this->locationsObj->makebranch($location);

			$locs = Array();

			if ($location != false)
				$locs[] = $location;

			foreach($rootBranch as $loc)
				$locs[] = $loc['id'];

			$this->locs = $locs;
		}

		return $this->locs;
	}
	/* END METHOD getSubLocs */


	/* METHOD: createResultObject */

	/* SYNOPSIS
	 * This method creates the result object and returns it
	 * END SYNOPSIS */

	/* HISTORY
	 * Created Fri Jun 23 16:15:12 MDT 2006 by pdrapeau
	 * END HISTORY */
	private function createResultObject (
		$resultSet = false		// I: result set from query method, or false for no results in object
	) {

		// if no result set was passed, INIT to empty array
		if ($resultSet === false) {
			$resultSet = Array();
		}

		// first build an array of the values of the construct params (this needs to be done to
		// actually populate them at this time)
		$resultObjParams = Array();
		$resultObjParams[] = &$resultSet;
		foreach ($this->resultObjectProp[$this->resultType] as $resultVar)
			$resultObjParams[] = $this->{$resultVar};

		$resultObject = call_user_func_array(Array(new ReflectionClass($this->resultTypeObjects[$this->resultType]), 'newInstance'), $resultObjParams);
		return $resultObject;
	}
	/* END METHOD createResultObject */
}
/* END CLASS userSearch */


/* CLASS: userSearchResults */

/* SYNOPSIS
 * This class is the base container for user search results, it will hold a result set, along with
 * the total number of results in the set
 * END SYNOPSIS */

/* HISTORY
 * Created May 31, 2006 by pdrapeau
 * END HISTORY */
class userSearchResults {

	/* DEFINE PROPERTIES */
	private $masterdb;			// reference to master database object (PTR)
	private $usersdb;			// reference to users database object (PTR)
	private $cache;				// reference to cache object (PTR)
	private $config;			// reference to config array (PTR)
	public $results;			// results from user search (ARRAY)
	public $totalResults;		// total results from search (INT)
	public $debugOutput;		// debug output passed from query object
	/* END DEFINE PROPERTIES */


	/* CONSTRUCTOR */
	function __construct (
		$results,
		$totalResults,
		$debugOutput = false
	) {
		// get the database objects from the global scope (this is probablly not the correct way to go about this
		// however there are enough db objects that passing them on construct becomes cumbersome)
		global $masterdb, $usersdb, $cache, $config;
		$this->masterdb = &$masterdb;
		$this->usersdb = &$usersdb;
		$this->cache = &$cache;
		$this->config = &$config;
		$this->debugOutput = $debugOutput;

		// initially the result set is just simply a array of UIDs unless getUserData is called
		$this->results = $results;
		$this->totalResults = $totalResults;
	}
	/* END CONSTRUCTOR */


	/* METHOD: getUserData */

	/* SYNOPSIS
	 * This method gets user data which is used in the result set for all users in the result set
	 * - userName
	 * - picId
	 * - age
	 * - sex
	 * - location
	 * - tagLine
	 * - online
	 * END SYNOPSIS */

	/* HISTORY
	 * Created May 30, 2006 by pdrapeau
	 * END HISTORY */
	function getUserData () {
		// init locations to populate user location in result list
		$locations = new category( $configdb, "locs");

		// check to see if the results which have been returned contain multiple values, and if so create two arrays from
		// the single array (one which will be passed into getUserInfo and one which will be used to fill in vars in the populated
		// user info)
		$extraValArray = Array();
		if (is_array($this->results[0]) === true) {
			$resultArray = Array();
			foreach ($this->results as $resultIdx => $result) {
				$resultArray[$resultIdx] = array_shift($result);
				$extraValArray[$resultIdx] = $result;
			}
			$this->results = $resultArray;
			unset($resultArray);
		}

		// first get the user data for the user
		$userData = getUserInfo($this->results);

		// next get the taglines for the users
		$userTaglines = $this->cache->get_multi($this->results, 'tagline-');
		$notCached = array_diff($this->results, array_keys($userTaglines));

		if (count($notCached) > 0) {
			$resultSet = $this->usersdb->prepare_query("SELECT userid, ntagline FROM profile WHERE userid IN (%)", $notCached);
			while($row = $resultSet->fetchrow()){
				$userTaglines[$row['userid']] = $row['ntagline'];
				$this->cache->put("tagline-$row[userid]", $row['ntagline'], 86400*7);
			}

			// if no results are found for the keys in the database, they will never get set in the cache
			// and we will keep hitting the database every single time, thus we should cache the lack of results as well
			$notCached = array_diff($this->results, array_keys($userTaglines));
			foreach ($notCached as $key => $uid) {
				$this->cache->put("tagline-$uid", "", 86400*7);
				$userTaglines[$uid] = "";
			}
		}

		// now re-build results array from scratch to contain the data that is required within this object
		$newResults = Array();
		foreach ($this->results as $key => $userId) {
			if (isset($userData[$userId])) {
				$resultRecord = Array();
				$resultRecord['userId'] = $userId;
				$resultRecord['userName'] = $userData[$userId]['username'];
				$resultRecord['picId'] = $userData[$userId]['firstpic'];
				$resultRecord['age'] = $userData[$userId]['age'];
				$resultRecord['sex'] = $userData[$userId]['sex'];
				$resultRecord['locationId'] = $userData[$userId]['loc'];
				$resultRecord['locationName'] = $locations->getCatName($resultRecord['locationId']);
				$resultRecord['tagLine'] = $userTaglines[$userId];
				$resultRecord['online'] = $userData[$userId]['online'];

				// deal with any extra values that may have been passed from the query such as say from spotlight history
				if (isset($extraValArray[$key])) {
					foreach ($extraValArray[$key] as $keyName => $keyValue)
						$resultRecord[$keyName] = $keyValue;
				}

				// check to see if a picId has been set for the result set, and if so map it to a URL
				if (isset($resultRecord['picId']) === true && $resultRecord['picId'] != 0) {
					$resultRecord['picUrl'] = $this->config['thumbloc'];
					$resultRecord['picUrl'] .= floor($resultRecord['userId']/1000) . "/";
					$resultRecord['picUrl'] .= weirdmap($resultRecord['userId']) . "/".$resultRecord['picId'].".jpg";
				} else {
					$resultRecord['picUrl'] = false;
				}

				$newResults[] = $resultRecord;
			}
		}


		// set results to newResults
		$this->results = $newResults;
		reset($this->results);

		// if this is a userSearchResults object, we can simply re-set total results at this point
		if (get_class($this) == "userSearchResults")
			$this->totalResults = count($this->results);

	}
	/* END METHOD getUserData */


	/* METHOD: getResult */

	/* SYNOPSIS
	 * This method returns a result from the results array, and advances the array pointer ahead
	 * END SYNOPSIS */

	/* HISTORY
	 * Created June 1, 2006 by pdrapeau
	 * END HISTORY */
	function getResult () {
		$result = each ($this->results);
		return $result['value'];
	}
	/* END METHOD getResult */


	/* METHOD: getFormattedDebugOutput */

	/* SYNOPSIS
	 * This method takes the debug output passed to this class on construct and formats it
	 * returning the formatted version
	 * END SYNOPSIS */

	/* HISTORY
	 * Created Fri Jun 23 18:16:21 MDT 2006 by pdrapeau
	 * END HISTORY */
	 public function getFormattedDebugOutput () {
		// INIT formatted output array
	 	$formattedOutput = Array();

	 	if ($this->debugOutput === false)
	 		return false;

		// split debug output into multi-dimentional array
		foreach ($this->debugOutput as $debugKey => $debugLines) {
			$debugLines = split("\n", $debugLines);
			if (count($debugLines) > 1) {
				$debugSectionTitle = array_shift($debugLines);
				$debugSectionTitle = ereg_replace('=.+>', "", $debugSectionTitle);
				array_pop($debugLines);
				$formattedOutput[$debugKey] = Array('title' => $debugSectionTitle, 'lines' => $debugLines);
			} else {
				ereg("^(\[.+\])+ (.*)$", $debugLines[0], $matches);
				$itemTag = $matches[1];
				$debugLines[0] = $matches[2];
				$formattedOutput[$debugKey] = Array('title' => $itemTag, 'lines' => $debugLines);
			}
		}

		return $formattedOutput;
	}
	/* END METHOD getFormattedDebugOutput */
}
/* END CLASS userSearchResults */


/* CLASS: userSearchResultsList */

/* SYNOPSIS
 * This class extends userSearchResults, adding properties and/or methods that are useful for dealing with the search
 * results when their presented as a paged list
 * END SYNOPSIS */

/* HISTORY
 * Created May 31, 2006 by pdrapeau
 * END HISTORY */
class userSearchResultsList extends userSearchResults {

	/* DEFINE PROPERTIES */
	public $pages;				// pages of search results (INT)
	public $resultsOnPage;		// number of results per page in search (INT)
	public $curPageNumber;		// current page number result set is for (INT)
	public $fullResults;		// flag for full result set mode (BOOL)
	public $fullResultSet;		// container for full result set when it has been passed (ARRAY)
	public $resultsInRetSet;	// number of results returned in a full result set (INT)
	public $pageStartIdx;		// initial start IDX of current page when using a full result set (INT)
	public $pageEndIdx;			// initial end IDX of current page when using a full result set (INT)
	/* END DEFINE PROPERTIES */

	/* CONSTRUCTOR */
	function __construct (
		$results,
		$totalResults,
		$pages,
		$resultsOnPage,
		$curPageNumber,
		$resultsInRetSet = false,
		$pageStartIdx = false,
		$pageEndIdx = false,
		$debugOutput = false
	) {
		// check if we got a full result set back or not, and init vars approiately
		if ($resultsInRetSet !== false && $pageStartIdx !== false && $pageEndIdx !== false) {
			$this->fullResults = true;
			$this->fullResultSet = $results;
		} else {
			$this->fullResults = false;
			$this->fullResultSet = false;
		}

		// now if we got a full result set, slice the $results array into a partial result set for the current page
		// since the full result set has already been stored in the object (as simply nonpopulated UID values)
		// when (if) this result object is populated, it will be only for the items on the current page
		if ($this->fullResults === true) {
			$results = array_slice ($results, $pageStartIdx, $resultsOnPage);
		}

		// call the parents (userSearchResults) constructor with correct args
		parent::__construct($results, $totalResults, $debugOutput);

		// process anything specific to userSearchResultsList
		$this->pages = $pages;
		$this->resultsOnPage = $resultsOnPage;
		$this->curPageNumber = $curPageNumber;
		$this->resultsInRetSet = $resultsInRetSet;
		$this->pageStartIdx = $pageStartIdx;
		$this->pageEndIdx = $pageEndIdx;
	}
	/* END CONSTRUCTOR */


	/* METHOD: getUserData */

	/* SYNOPSIS
	 * This method acts as a wrapper for getUserData in paged result sets
	 * END SYNOPSIS */

	/* HISTORY
	 * Created May 30, 2006 by pdrapeau
	 * END HISTORY */
	function getUserData () {
		// call the parent method
		parent::getUserData();

		// re-set results on page and total results
		$newCount = count($this->results);
		$this->totalResults = $this->totalResults - ($this->resultsOnPage - $newCount);
		$this->resultsOnPage = $newCount;
	}
	/* END METHOD getUserData */
}
/* END CLASS userSearchResultsList */


/* CLASS: userSearchMenuOptions */

/* SYNOPSIS
 * This class is a container for all the userSearch options found on the site (in this case both the side bar
 * and the advanced search) it will generate the selects and check boxes which get passed into the template
 * END SYNOPSIS */

/* HISTORY
 * Created Jun 20, 2006 by pdrapeau
 * END HISTORY */
class userSearchMenuOptions {

	/* DEFINE PROPERTIES */
	public $searchNameScope;		// default selected value (STRING: starts/includes/ends)
	public $searchName; 			// default output value (STRING)
	public $searchMinAge;			// default output value (INT)
	public $searchMaxAge;			// default output value (INT)
	public $searchSex;				// default selected value (STRING: Male/Female/Both)
	public $searchLocation;			// default selected value (INT)
	public $searchSexuality;		// default selected value (INT)
	public $searchInterest;			// default selected value (INT)
	public $searchActivity;			// default selected value (INT)
	public $searchPicture;			// default selected value (INT)
	public $searchSingleOnly;		// default selected value (BOOL)
	public $searchShowList;			// default selected value (BOOL)
	public $nameScopeSelect;		// HTML output
	public $sexSelect;				// HTML output
	public $locationSelect;			// HTML output
	public $interestSelect;			// HTML output
	public $activitySelect;			// HTML output
	public $pictureSelect;			// HTML output
	public $sexualitySelect;		// HTML output
	public $singleCheck;			// HTML output
	public $listCheck;				// HTML output
	/* END DEFINE PROPERTIES */


	/* CONSTRUCTOR */
	function __construct (
		$createMenuOptions  = true,	 // I: true/false create options with defaults used as set
		$callingFunction	= false, // I: name of the function calling the construct
		$requestType	    = false, // I: request type from form submit (used in conjunction with requestParams)
		$requestParams	    = false	 // I: request parameters array from a form submit, will be used to override values internally
	) {
		// INIT Globals
		global $config, $userData;

		// setup what default along with not applicable values should be for each param
		$paramDefaults = Array(	'searchNameScope' 	=> Array("starts", "starts"),
							   	'searchName' 		=> Array("", ""),
							   	'searchMinAge' 		=> Array($config['minAge'], $config['minAge']),
							   	'searchMaxAge' 		=> Array($config['maxAge'], $config['maxAge']),
							   	'searchSex' 		=> Array("Both", "Both"),
							   	'searchLocation' 	=> Array(0, 0),
							   	'searchSexuality' 	=> Array(0, 0),
							   	'searchInterest' 	=> Array(0, 0),
							   	'searchActivity' 	=> Array(1, 0),
							   	'searchPicture'		=> Array(1, 0),
							   	'searchSingleOnly'  => Array(false, false),
							   	'searchShowList'	=> Array(false, false));


		// set what the defaults should be if the user is logged in, and what userData key they map to
		$userDefaults = Array ( 'searchMinAge'		=> 'defaultminage',
		 						'searchMaxAge'		=> 'defaultmaxage',
		 						'searchSex'			=> 'defaultsex',
		 						'searchLocation' 	=> 'defaultloc');

		// set what values are mapped to when submitted and placed in the $requestParams array
		$reqParamMap = Array(   'searchNameScope' 	=> 'nameScope',
							   	'searchName' 		=> 'userName',
							   	'searchMinAge' 		=> 'ageRangeMin',
							   	'searchMaxAge' 		=> 'ageRangeMax',
							   	'searchSex' 		=> 'sex',
							   	'searchLocation' 	=> 'location',
							   	'searchSexuality' 	=> 'sexuality',
							   	'searchInterest' 	=> 'interest',
							   	'searchActivity' 	=> 'active',
							   	'searchPicture'		=> 'pic',
							   	'searchSingleOnly'  => 'singleUsers',
							   	'searchShowList'	=> 'displayList');

		// figure out if we should be re-setting params to match those passed in the request
		$resetToRequest = false;
		if ($requestParams && is_array($requestParams)) {
			// default to true except for certian exceptions
			$resetToRequest = true;

			// exclude setting the sort block in all function except for the userSearch query
			if (($requestType != 'query' && $requestType != 'onlineByPrefs') && $callingFunction == 'incSortBlock')
				$resetToRequest = false;

			// exclude onlineByPrefs function call
			if ($callingFunction == 'onlineByPrefs')
				$resetToRequest = false;

			// exclude randomByPrefs function call
			if ($callingFunction == 'randomByPrefs')
				$resetToRequest = false;
		}


		// okay, if $resetToRequest is true, proceed to re-set
		if ($resetToRequest === true) {
			foreach ($paramDefaults as $paramName => $defaultValue) {
				if (isset($requestParams[$reqParamMap[$paramName]]) === true && $requestParams[$reqParamMap[$paramName]] != false)
					$this->{$paramName} = $requestParams[$reqParamMap[$paramName]];
				else {
					$this->{$paramName} = $defaultValue[1];
				}
			}
		}

		// if resetToRequest is set to false, set values to the user defaults falling back
		if ($resetToRequest === false) {
			foreach ($paramDefaults as $paramName => $defaultValue) {
				if ($userData['loggedIn'] === true && isset($userDefaults[$paramName]))
					$this->{$paramName} = $userData[$userDefaults[$paramName]];
				else
					$this->{$paramName} = $paramDefaults[$paramName][0];
			}
		}

		// in the case of a streight username search, only the username should be re-set from the request
		if (isset($requestParams['userName']) && $requestParams['userName'] != false && isset($requestParams['nameScope']) == false)
			$this->searchName = $requestParams['userName'];

		if ($createMenuOptions === true)
			call_user_func(array(&$this, 'createMenuOptions'));

		return true;
	}
	/* END CONSTRUCTOR */


	/* METHOD: createMenuOptions */

	/* SYNOPSIS
	 * This populates the HTML output vars with the approiate values
	 * END SYNOPSIS */

	/* HISTORY
	 * Created Jun 20, 2006 by pdrapeau
	 * END HISTORY */
	function createMenuOptions () {
		// INIT Globals
		global $configdb;


		// create categories for both location and interests
		$locations = new category( $configdb, "locs");
		$interests = new category( $configdb, "interests");

		// init categories and interests branches, inserting option 0 for all
		$locationBranch = $locations->makeBranch();
		$interestBranch = $interests->makeBranch();
		array_unshift ($locationBranch, Array('id' => '0', 'depth' => '0', 'name' => 'All Locations', 'parent' => 0, 'isparent' => 1));
		array_unshift ($interestBranch, Array('id' => '0', 'depth' => '0', 'name' => 'All Interests', 'parent' => 0, 'isparent' => 1));

		// define values for selects used in the page generation
		$nameScopeSelectDef = Array ( 	'starts'   => "Starts With",
										'includes' => "Includes",
										'ends'     => "Ends With");

		$sexSelectDef = Array (	'Both'   => "Male/Female",
								'Male'	 => "Male",
								'Female' => "Female");

		$activitySelectDef = Array(	0 	=> "All Users",
									1 	=> "Active Recently",
									2 	=> "Online");

		$pictureSelectDef = Array( 0  => "All Users",
								   1  => "With Pictures",
								   2  => "With a Verified Picture");

		$sexualitySelectDef = Array ( 0  => "Any Sexuality",
									  1  => "Heterosexual",
									  2  => "Homosexual",
									  3  => "Bisexual/Open-Minded");

		// init select arrays that will be passed on to the template, using values for defaults which have been set
		$this->nameScopeSelect = make_select_list_key($nameScopeSelectDef, $this->searchNameScope);
		$this->sexSelect = make_select_list_key($sexSelectDef, $this->searchSex);
		$this->locationSelect = makeCatSelect($locationBranch, $this->searchLocation);
		$this->interestSelect = makeCatSelect($interestBranch, $this->searchInterest);
		$this->activitySelect = make_select_list_key($activitySelectDef, $this->searchActivity);
		$this->pictureSelect = make_select_list_key($pictureSelectDef, $this->searchPicture);
		$this->sexualitySelect = make_select_list_key($sexualitySelectDef, $this->searchSexuality);
		$this->singleCheck = makeCheckBox('requestParams[singleUsers]', 'Single Users Only', $this->searchSingleOnly);
		$this->listCheck = makeCheckBox('requestParams[displayList]', 'Show List', $this->searchShowList);

		return true;
	}
	/* END METHOD createMenuOptions */
}
/* END CLASS userSearchMenuOptions */


/* END MODULE userSearch.php */
?>
